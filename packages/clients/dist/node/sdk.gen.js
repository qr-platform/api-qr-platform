"use strict";
// This file is auto-generated by @hey-api/openapi-ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteSettingsCustomBySettingSlug = exports.postSettingsCustom = exports.getSettingsCustom = exports.getSettings = exports.getPlansCurrent = exports.getPlans = exports.getRoles = exports.getWorkspacesByWorkspaceIdMembers = exports.postWorkspacesByWorkspaceIdMembersByUserIdRole = exports.getWorkspacesByWorkspaceIdMembersByUserIdRole = exports.deleteWorkspacesByWorkspaceIdMembersByUserIdRole = exports.putWorkspacesByWorkspaceId = exports.getWorkspacesByWorkspaceId = exports.deleteWorkspacesByWorkspaceId = exports.postWorkspaces = exports.getWorkspaces = exports.deleteMembersByUserIdRoleByRoleName = exports.postMembersByUserIdRole = exports.getMembersByUserIdRoles = exports.deleteMembersByUserId = exports.postMembers = exports.getMembers = exports.getInvitesByTokenDecline = exports.getInvitesByTokenAccept = exports.deleteInvitesByInvitationId = exports.getInvitesMe = exports.postInvites = exports.getInvites = exports.postOrgsCurrentByOrgId = exports.postOrgsFirst = exports.putOrgs = exports.getOrgsCurrent = exports.putApiKeysByApiKeyIdStatus = exports.putApiKeysByApiKeyId = exports.getApiKeysByApiKeyId = exports.deleteApiKeysByApiKeyId = exports.postApiKeys = exports.getApiKeys = exports.postAuthPasswordChange = exports.postAuthPasswordResetVerify = exports.postAuthPasswordReset = exports.getAuthSignOut = exports.getAuthMe = exports.postAuthEmailVerify = exports.postAuthEmailVerifySend = exports.postAuthSignInVerify = exports.postAuthSignIn = exports.postAuthRegisterVerifyResend = exports.postAuthRegisterVerify = exports.postAuthRegister = void 0;
exports.deleteCodesByCodeIdVersionsByVersionLinksByType = exports.deleteCodesByCodeIdVersionsByVersionLinks = exports.getCodesByCodeIdVersionByVersionByTypeLink = exports.getCodesByCodeIdVersionByVersionByType = exports.postCodesByCodeIdVersionByVersionRestore = exports.getCodesByCodeIdVersions = exports.deleteCodesByCodeIdVersions = exports.getCodesByCodeIdVersionByVersion = exports.postCodesLinksRefresh = exports.postCodesByCodeIdValidate = exports.postCodesValidate = exports.postCodesGenerateByType = exports.postCodesBulkGet = exports.postCodesByCodeIdRestore = exports.deleteCodesByCodeIdPermanent = exports.deleteCodesPermanent = exports.putCodesByCodeIdOptions = exports.postCodes = exports.getCodes = exports.deleteCodes = exports.putCodesByCodeId = exports.getCodesByCodeId = exports.deleteCodesByCodeId = exports.getCodesLinks = exports.getCodesDeleted = exports.putCodesByCodeIdRouterRulesByRouterRuleId = exports.getCodesByCodeIdRouterRulesByRouterRuleId = exports.deleteCodesByCodeIdRouterRulesByRouterRuleId = exports.postCodesByCodeIdRouterRules = exports.getCodesByCodeIdRouterRules = exports.getCodesByCodeIdScans = exports.getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue = exports.putWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = exports.getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = exports.deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = exports.getWorkspacesByWorkspaceIdSettingsService = exports.getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue = exports.putWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = exports.getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = exports.deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = exports.postWorkspacesByWorkspaceIdSettingsCustom = exports.getWorkspacesByWorkspaceIdSettingsCustom = exports.getWorkspacesByWorkspaceIdSettings = exports.getSettingsServiceBySettingSlugValue = exports.putSettingsServiceBySettingSlug = exports.getSettingsServiceBySettingSlug = exports.getSettingsService = exports.getSettingsCustomBySettingSlugValue = exports.putSettingsCustomBySettingSlug = exports.getSettingsCustomBySettingSlug = void 0;
exports.postWorkspacesByWorkspaceIdRouterRuleTemplates = exports.getWorkspacesByWorkspaceIdRouterRules = exports.getRouterRules = exports.putRouterRuleTemplatesByRouterRuleTemplateId = exports.getRouterRuleTemplatesByRouterRuleTemplateId = exports.deleteRouterRuleTemplatesByRouterRuleTemplateId = exports.postRouterRuleTemplates = exports.getRouterRuleTemplates = exports.getCountryCodes = exports.getBordersWorkspaceByWorkspaceId = exports.putBordersByBorderIdOptions = exports.putBordersByBorderId = exports.getBordersByBorderId = exports.deleteBordersByBorderId = exports.getBordersBase = exports.postBorders = exports.getBorders = exports.getTextsWorkspaceByWorkspaceId = exports.putTextsByTextIdOptions = exports.putTextsByTextId = exports.getTextsByTextId = exports.deleteTextsByTextId = exports.getTextsBase = exports.postTexts = exports.getTexts = exports.getStylesWorkspaceByWorkspaceId = exports.putStylesByStyleIdOptions = exports.putStylesByStyleId = exports.getStylesByStyleId = exports.deleteStylesByStyleId = exports.getStylesBase = exports.postStyles = exports.getStyles = exports.getTemplatesWorkspaceByWorkspaceId = exports.putTemplatesByTemplateIdOptions = exports.putTemplatesByTemplateId = exports.getTemplatesByTemplateId = exports.deleteTemplatesByTemplateId = exports.getTemplatesBase = exports.postTemplates = exports.getTemplates = exports.deleteCodesByCodeIdLinksByType = exports.deleteCodesByCodeIdLinks = exports.getCodesByCodeIdByTypeLink = exports.getCodesByCodeIdByType = exports.deleteCodesByCodeIdVersionsLinksByType = exports.deleteCodesByCodeIdVersionsLinks = void 0;
const client_gen_1 = require("./client.gen");
/**
 * Register New User
 * Registers a new user and organization. Sends a verification code and token via email
 */
const postAuthRegister = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/register',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthRegister = postAuthRegister;
/**
 * Verify Registration Code or Token
 * Verifies the 6-digit code or token sent via email after registration
 */
const postAuthRegisterVerify = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/register-verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthRegisterVerify = postAuthRegisterVerify;
/**
 * Resend Registration Verification Code and Token
 * Resends the 6-digit verification code or token to the user's email.
 */
const postAuthRegisterVerifyResend = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/register-verify-resend',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthRegisterVerifyResend = postAuthRegisterVerifyResend;
/**
 * Sign In User
 * Initiates user sign-in. Returns an access token if password is provided and correct, otherwise indicates if passwordless verification is needed
 */
const postAuthSignIn = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/sign-in',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthSignIn = postAuthSignIn;
/**
 * Verify Sign In Code or Token
 * Verifies the 6-digit code or token sent via email for passwordless sign-in
 */
const postAuthSignInVerify = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/sign-in-verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthSignInVerify = postAuthSignInVerify;
/**
 * Send Email Verification Code and Token
 * Sends a verification code and token to the user's email if it's not already verified.
 */
const postAuthEmailVerifySend = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/email-verify-send',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthEmailVerifySend = postAuthEmailVerifySend;
/**
 * Verify Email Address
 * Verifies the user's email address using the provided code or token.
 */
const postAuthEmailVerify = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/email-verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthEmailVerify = postAuthEmailVerify;
/**
 * Get Current User
 * Retrieves the details of the currently authenticated user
 */
const getAuthMe = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/me',
        ...options
    });
};
exports.getAuthMe = getAuthMe;
/**
 * Sign Out User
 * Signs out the current user by clearing relevant cookies/session data
 */
const getAuthSignOut = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/sign-out',
        ...options
    });
};
exports.getAuthSignOut = getAuthSignOut;
/**
 * Request Password Reset
 * Sends a password reset email with a verification token
 */
const postAuthPasswordReset = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/password/reset',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthPasswordReset = postAuthPasswordReset;
/**
 * Verify Password Reset
 * Verifies the password reset token and sets a new password
 */
const postAuthPasswordResetVerify = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/password/reset-verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthPasswordResetVerify = postAuthPasswordResetVerify;
/**
 * Change Password
 * Changes the password for the authenticated user
 */
const postAuthPasswordChange = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/auth/password/change',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postAuthPasswordChange = postAuthPasswordChange;
/**
 * List API keys
 * Retrieves all API keys for the current organization.
 */
const getApiKeys = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api-keys',
        ...options
    });
};
exports.getApiKeys = getApiKeys;
/**
 * Create API key
 * Creates a new API key for the current organization.
 */
const postApiKeys = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api-keys',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postApiKeys = postApiKeys;
/**
 * Delete API key
 * Deletes an API key by its ID.
 */
const deleteApiKeysByApiKeyId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api-keys/{apiKeyId}',
        ...options
    });
};
exports.deleteApiKeysByApiKeyId = deleteApiKeysByApiKeyId;
/**
 * Get API key details
 * Retrieves details of a specific API key by its ID.
 */
const getApiKeysByApiKeyId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api-keys/{apiKeyId}',
        ...options
    });
};
exports.getApiKeysByApiKeyId = getApiKeysByApiKeyId;
/**
 * Update API key
 * Updates an existing API key by its ID.
 */
const putApiKeysByApiKeyId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api-keys/{apiKeyId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putApiKeysByApiKeyId = putApiKeysByApiKeyId;
/**
 * Change API key status
 * Changes the status of an API key (activate or disable).
 */
const putApiKeysByApiKeyIdStatus = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api-keys/{apiKeyId}/status',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putApiKeysByApiKeyIdStatus = putApiKeysByApiKeyIdStatus;
/**
 * Get current organization
 * Retrieves details of the current active organization for the authenticated user.
 */
const getOrgsCurrent = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/orgs/current',
        ...options
    });
};
exports.getOrgsCurrent = getOrgsCurrent;
/**
 * Update current organization
 * Updates the details of the current active organization.
 */
const putOrgs = (options) => {
    return (options?.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/orgs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.putOrgs = putOrgs;
/**
 * Create first organization
 * Creates the first organization for a new user. Only works when the user has no organizations.
 */
const postOrgsFirst = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/orgs/first',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postOrgsFirst = postOrgsFirst;
/**
 * Switch current organization
 * Switches the current active organization for the authenticated user.
 */
const postOrgsCurrentByOrgId = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/orgs/current/{orgId}',
        ...options
    });
};
exports.postOrgsCurrentByOrgId = postOrgsCurrentByOrgId;
/**
 * List organization invitations
 * Retrieves all invitations for the current organization.
 */
const getInvites = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/invites',
        ...options
    });
};
exports.getInvites = getInvites;
/**
 * Create invitation
 * Creates a new invitation to join the organization with a specified role.
 */
const postInvites = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/invites',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postInvites = postInvites;
/**
 * List my invitations
 * Retrieves all invitations sent by the current user.
 */
const getInvitesMe = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/invites/me',
        ...options
    });
};
exports.getInvitesMe = getInvitesMe;
/**
 * Delete invitation
 * Deletes an invitation by its ID.
 */
const deleteInvitesByInvitationId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/invites/{invitationId}',
        ...options
    });
};
exports.deleteInvitesByInvitationId = deleteInvitesByInvitationId;
/**
 * Accept invitation
 * Accepts an invitation using the provided token. Creates a user account if needed.
 */
const getInvitesByTokenAccept = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/invites/{token}/accept',
        ...options
    });
};
exports.getInvitesByTokenAccept = getInvitesByTokenAccept;
/**
 * Decline invitation
 * Declines an invitation using the provided token.
 */
const getInvitesByTokenDecline = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/invites/{token}/decline',
        ...options
    });
};
exports.getInvitesByTokenDecline = getInvitesByTokenDecline;
/**
 * List organization members
 * Retrieves all members of the current organization.
 */
const getMembers = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/members',
        ...options
    });
};
exports.getMembers = getMembers;
/**
 * Add a member to organization
 * Adds a new member to the current organization with the specified role.
 */
const postMembers = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/members',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postMembers = postMembers;
/**
 * Remove member from organization
 * Removes a member from the current organization.
 */
const deleteMembersByUserId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/members/{userId}',
        ...options
    });
};
exports.deleteMembersByUserId = deleteMembersByUserId;
/**
 * Get member roles
 * Retrieves all roles assigned to a member in the current organization.
 */
const getMembersByUserIdRoles = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/members/{userId}/roles',
        ...options
    });
};
exports.getMembersByUserIdRoles = getMembersByUserIdRoles;
/**
 * Add role to member
 * Assigns a new role to a member in the current organization.
 */
const postMembersByUserIdRole = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/members/{userId}/role',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.postMembersByUserIdRole = postMembersByUserIdRole;
/**
 * Remove role from member
 * Removes a role from a member in the current organization.
 */
const deleteMembersByUserIdRoleByRoleName = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/members/{userId}/role/{roleName}',
        ...options
    });
};
exports.deleteMembersByUserIdRoleByRoleName = deleteMembersByUserIdRoleByRoleName;
/**
 * List workspaces
 * Retrieves all workspaces for the current organization.
 */
const getWorkspaces = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces',
        ...options
    });
};
exports.getWorkspaces = getWorkspaces;
/**
 * Create a new workspace
 * Creates a new workspace in the current organization.
 */
const postWorkspaces = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postWorkspaces = postWorkspaces;
/**
 * Delete workspace
 * Deletes a workspace by its unique identifier.
 */
const deleteWorkspacesByWorkspaceId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}',
        ...options
    });
};
exports.deleteWorkspacesByWorkspaceId = deleteWorkspacesByWorkspaceId;
/**
 * Get workspace by ID
 * Retrieves a specific workspace by its unique identifier.
 */
const getWorkspacesByWorkspaceId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}',
        ...options
    });
};
exports.getWorkspacesByWorkspaceId = getWorkspacesByWorkspaceId;
/**
 * Update workspace
 * Updates an existing workspace by its unique identifier.
 */
const putWorkspacesByWorkspaceId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putWorkspacesByWorkspaceId = putWorkspacesByWorkspaceId;
/**
 * Remove role from workspace member
 * Removes a role from a user in a specific workspace.
 */
const deleteWorkspacesByWorkspaceIdMembersByUserIdRole = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/members/{userId}/role',
        ...options
    });
};
exports.deleteWorkspacesByWorkspaceIdMembersByUserIdRole = deleteWorkspacesByWorkspaceIdMembersByUserIdRole;
/**
 * Get user roles in workspace
 * Retrieves the roles assigned to a specific user in a workspace.
 */
const getWorkspacesByWorkspaceIdMembersByUserIdRole = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/members/{userId}/role',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdMembersByUserIdRole = getWorkspacesByWorkspaceIdMembersByUserIdRole;
/**
 * Add role to workspace member
 * Assigns a role to a user in a specific workspace.
 */
const postWorkspacesByWorkspaceIdMembersByUserIdRole = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/members/{userId}/role',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.postWorkspacesByWorkspaceIdMembersByUserIdRole = postWorkspacesByWorkspaceIdMembersByUserIdRole;
/**
 * List workspace members
 * Retrieves all members in a specific workspace.
 */
const getWorkspacesByWorkspaceIdMembers = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/members',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdMembers = getWorkspacesByWorkspaceIdMembers;
/**
 * List all roles
 * Retrieves all system roles with their associated permission scopes.
 */
const getRoles = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/roles',
        ...options
    });
};
exports.getRoles = getRoles;
/**
 * List available plans
 * Retrieves all available plans. If authenticated, the current plan will be marked.
 */
const getPlans = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/plans',
        ...options
    });
};
exports.getPlans = getPlans;
/**
 * Get current plan
 * Retrieves the current plan for the authenticated organization with usage details.
 */
const getPlansCurrent = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/plans/current',
        ...options
    });
};
exports.getPlansCurrent = getPlansCurrent;
/**
 * Get all organization settings
 * Retrieves all settings (custom and service) for the organization.
 */
const getSettings = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings',
        ...options
    });
};
exports.getSettings = getSettings;
/**
 * Get all custom settings
 * Retrieves all custom settings for the organization.
 */
const getSettingsCustom = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/custom',
        ...options
    });
};
exports.getSettingsCustom = getSettingsCustom;
/**
 * Create custom setting
 * Creates a new custom setting for the organization.
 */
const postSettingsCustom = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/custom',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postSettingsCustom = postSettingsCustom;
/**
 * Delete custom setting
 * Deletes a custom setting by its slug.
 */
const deleteSettingsCustomBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/custom/{settingSlug}',
        ...options
    });
};
exports.deleteSettingsCustomBySettingSlug = deleteSettingsCustomBySettingSlug;
/**
 * Get custom setting by slug
 * Retrieves a specific custom setting by its slug.
 */
const getSettingsCustomBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/custom/{settingSlug}',
        ...options
    });
};
exports.getSettingsCustomBySettingSlug = getSettingsCustomBySettingSlug;
/**
 * Update custom setting
 * Updates an existing custom setting by its slug.
 */
const putSettingsCustomBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/custom/{settingSlug}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putSettingsCustomBySettingSlug = putSettingsCustomBySettingSlug;
/**
 * Get custom setting value
 * Retrieves only the value of a specific custom setting by its slug.
 */
const getSettingsCustomBySettingSlugValue = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/custom/{settingSlug}/value',
        ...options
    });
};
exports.getSettingsCustomBySettingSlugValue = getSettingsCustomBySettingSlugValue;
/**
 * Get all service settings
 * Retrieves all service settings for the organization.
 */
const getSettingsService = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/service',
        ...options
    });
};
exports.getSettingsService = getSettingsService;
/**
 * Get service setting by slug
 * Retrieves a specific service setting by its slug.
 */
const getSettingsServiceBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/service/{settingSlug}',
        ...options
    });
};
exports.getSettingsServiceBySettingSlug = getSettingsServiceBySettingSlug;
/**
 * Upsert service setting
 * Updates an existing service setting or creates it if it does not exist.
 */
const putSettingsServiceBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/service/{settingSlug}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putSettingsServiceBySettingSlug = putSettingsServiceBySettingSlug;
/**
 * Get service setting value
 * Retrieves only the value of a specific service setting by its slug.
 */
const getSettingsServiceBySettingSlugValue = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/settings/service/{settingSlug}/value',
        ...options
    });
};
exports.getSettingsServiceBySettingSlugValue = getSettingsServiceBySettingSlugValue;
/**
 * Get all workspace settings
 * Retrieves all settings (custom and service) for the workspace.
 */
const getWorkspacesByWorkspaceIdSettings = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdSettings = getWorkspacesByWorkspaceIdSettings;
/**
 * Get all workspace custom settings
 * Retrieves all custom settings for the workspace.
 */
const getWorkspacesByWorkspaceIdSettingsCustom = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/custom',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdSettingsCustom = getWorkspacesByWorkspaceIdSettingsCustom;
/**
 * Create workspace custom setting
 * Creates a new custom setting for the workspace.
 */
const postWorkspacesByWorkspaceIdSettingsCustom = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/custom',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.postWorkspacesByWorkspaceIdSettingsCustom = postWorkspacesByWorkspaceIdSettingsCustom;
/**
 * Delete workspace custom setting
 * Deletes a workspace custom setting by its slug.
 */
const deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}',
        ...options
    });
};
exports.deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlug;
/**
 * Get workspace custom setting by slug
 * Retrieves a specific workspace custom setting by its slug.
 */
const getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug;
/**
 * Update workspace custom setting
 * Updates an existing workspace custom setting by its slug.
 */
const putWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putWorkspacesByWorkspaceIdSettingsCustomBySettingSlug = putWorkspacesByWorkspaceIdSettingsCustomBySettingSlug;
/**
 * Get workspace custom setting value
 * Retrieves only the value of a specific workspace custom setting by its slug.
 */
const getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}/value',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue = getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue;
/**
 * Get all workspace service settings
 * Retrieves all service settings for the workspace.
 */
const getWorkspacesByWorkspaceIdSettingsService = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/service',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdSettingsService = getWorkspacesByWorkspaceIdSettingsService;
/**
 * Delete workspace service setting override
 * Deletes a workspace-level override for a service setting, reverting to organization defaults.
 */
const deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/service/{settingSlug}',
        ...options
    });
};
exports.deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlug;
/**
 * Get workspace service setting by slug
 * Retrieves a specific workspace service setting by its slug.
 */
const getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/service/{settingSlug}',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug;
/**
 * Upsert workspace service setting
 * Updates an existing workspace service setting or creates it if it does not exist.
 */
const putWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/service/{settingSlug}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putWorkspacesByWorkspaceIdSettingsServiceBySettingSlug = putWorkspacesByWorkspaceIdSettingsServiceBySettingSlug;
/**
 * Get workspace service setting value
 * Retrieves only the value of a specific workspace service setting by its slug.
 */
const getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/settings/service/{settingSlug}/value',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue = getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue;
/**
 * List QR Code Scans
 * Retrieves a paginated list of scans for a specific QR Code with optional filtering
 */
const getCodesByCodeIdScans = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/scans',
        ...options
    });
};
exports.getCodesByCodeIdScans = getCodesByCodeIdScans;
/**
 * List Router Rule Assignments
 * Retrieves all router rule assignments for a specific QR code with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data.
 */
const getCodesByCodeIdRouterRules = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/router-rules',
        ...options
    });
};
exports.getCodesByCodeIdRouterRules = getCodesByCodeIdRouterRules;
/**
 * Create Router Rule Assignment
 * Assigns a router rule to a QR code. You can reference an existing template by ID/name or create an inline custom rule. Rules with the same priority are evaluated in creation order. Scan limits and loop functionality are supported.
 */
const postCodesByCodeIdRouterRules = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/router-rules',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.postCodesByCodeIdRouterRules = postCodesByCodeIdRouterRules;
/**
 * Delete Router Rule Assignment
 * Deletes a router rule assignment. Rules that have been used (totalScans > 0) cannot be deleted to preserve analytics data. Consider disabling the rule instead.
 */
const deleteCodesByCodeIdRouterRulesByRouterRuleId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/router-rules/{routerRuleId}',
        ...options
    });
};
exports.deleteCodesByCodeIdRouterRulesByRouterRuleId = deleteCodesByCodeIdRouterRulesByRouterRuleId;
/**
 * Get Router Rule Assignment
 * Retrieves a specific router rule assignment for a QR code. Returns the rule with enriched template data, usage statistics, and audit information.
 */
const getCodesByCodeIdRouterRulesByRouterRuleId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/router-rules/{routerRuleId}',
        ...options
    });
};
exports.getCodesByCodeIdRouterRulesByRouterRuleId = getCodesByCodeIdRouterRulesByRouterRuleId;
/**
 * Update Router Rule Assignment
 * Updates a router rule assignment. You can change the rule source (template vs inline), priority, data configuration, and other settings. Validation is context-aware and will validate dynamicData against the existing or provided dataType. Priority conflicts are checked.
 */
const putCodesByCodeIdRouterRulesByRouterRuleId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/router-rules/{routerRuleId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putCodesByCodeIdRouterRulesByRouterRuleId = putCodesByCodeIdRouterRulesByRouterRuleId;
/**
 * List Soft Deleted QR Codes
 * Retrieves a paginated list of soft deleted QR Codes with optional filtering
 */
const getCodesDeleted = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/deleted',
        ...options
    });
};
exports.getCodesDeleted = getCodesDeleted;
/**
 * List QR Code Links
 * Retrieves a paginated list of all QR Code links with optional filtering
 */
const getCodesLinks = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/links',
        ...options
    });
};
exports.getCodesLinks = getCodesLinks;
/**
 * Soft Delete QR Code
 * Marks a QR Code as deleted without permanently removing it from the system. Usage limits are not affected and the code can potentially be restored.
 */
const deleteCodesByCodeId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}',
        ...options
    });
};
exports.deleteCodesByCodeId = deleteCodesByCodeId;
/**
 * Get QR Code
 * Retrieves a QR Code by its unique identifier
 */
const getCodesByCodeId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}',
        ...options
    });
};
exports.getCodesByCodeId = getCodesByCodeId;
/**
 * Update QR Code
 * Updates an existing QR Code with new data and options. Supports changing dataType for dynamic codes (e.g., from URL to WiFi configuration). When changing dataType, ensure metadata structure matches the new dataType requirements. This operation creates a new version of the QR code.
 */
const putCodesByCodeId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putCodesByCodeId = putCodesByCodeId;
/**
 * Bulk Soft Delete QR Codes
 * Soft deletes multiple QR codes by their IDs. The codes are marked as deleted but not permanently removed from the system.
 */
const deleteCodes = (options) => {
    return (options?.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes',
        ...options
    });
};
exports.deleteCodes = deleteCodes;
/**
 * List QR Codes
 * Retrieves a paginated list of QR Codes with optional filtering
 */
const getCodes = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes',
        ...options
    });
};
exports.getCodes = getCodes;
/**
 * Create QR Code
 * Creates a new QR Code with the specified data and options. Supports different dataTypes for dynamic codes including WiFi configuration, contact cards (vCard), plain text, email composition, calendar events, file downloads, and custom JSON data. Each dataType has specific metadata requirements that determine how the QR code is processed when scanned.
 */
const postCodes = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postCodes = postCodes;
/**
 * Partially update QR Code Options
 * Partially updates an existing QR Code's options using a deep merge. This will create a new version of the QR Code. Supports updating dataType for dynamic codes, which changes how the QR code content is processed when scanned (e.g., returning WiFi configuration instead of URL redirect).
 */
const putCodesByCodeIdOptions = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/options',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putCodesByCodeIdOptions = putCodesByCodeIdOptions;
/**
 * Bulk Permanent Delete QR Codes
 * Permanently deletes multiple QR codes by their IDs. This operation is irreversible and will remove all associated data including versions, files, and scans.
 */
const deleteCodesPermanent = (options) => {
    return (options?.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/permanent',
        ...options
    });
};
exports.deleteCodesPermanent = deleteCodesPermanent;
/**
 * Delete QR Code
 * Deletes a QR Code by its unique identifier
 */
const deleteCodesByCodeIdPermanent = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/permanent',
        ...options
    });
};
exports.deleteCodesByCodeIdPermanent = deleteCodesByCodeIdPermanent;
/**
 * Restore QR Code
 * Restores a soft-deleted QR Code by setting its deleted status to false. The code becomes active again and accessible through regular endpoints.
 */
const postCodesByCodeIdRestore = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/restore',
        ...options
    });
};
exports.postCodesByCodeIdRestore = postCodesByCodeIdRestore;
/**
 * Bulk Get QR Codes by ID List
 * Retrieves multiple QR codes by their IDs in a single request with access control and detailed error reporting.
 */
const postCodesBulkGet = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/bulk-get',
        ...options
    });
};
exports.postCodesBulkGet = postCodesBulkGet;
/**
 * Generate QR Code File Content
 * Generates a file content for a QR Code
 */
const postCodesGenerateByType = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/generate/{type}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.postCodesGenerateByType = postCodesGenerateByType;
/**
 * Validate QR Code Options
 * Validates QR Code styling options without generating or saving the QR Code
 */
const postCodesValidate = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/validate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postCodesValidate = postCodesValidate;
/**
 * Validate Existing QR Code
 * Validates an existing QR Code and updates its validation status in the database
 */
const postCodesByCodeIdValidate = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/validate',
        ...options
    });
};
exports.postCodesByCodeIdValidate = postCodesByCodeIdValidate;
/**
 * Bulk Refresh QR Code Links
 * Refreshes QR code links/files for all code versions matching the specified design element filters
 */
const postCodesLinksRefresh = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/links/refresh',
        ...options
    });
};
exports.postCodesLinksRefresh = postCodesLinksRefresh;
/**
 * Get QR Code version
 * Retrieves a specific version of a QR Code by ID and version number
 */
const getCodesByCodeIdVersionByVersion = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/version/{version}',
        ...options
    });
};
exports.getCodesByCodeIdVersionByVersion = getCodesByCodeIdVersionByVersion;
/**
 * Delete All QR Code Versions
 * Deletes all versions of a QR Code except the current one
 */
const deleteCodesByCodeIdVersions = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/versions',
        ...options
    });
};
exports.deleteCodesByCodeIdVersions = deleteCodesByCodeIdVersions;
/**
 * List QR Code versions
 * Retrieves all versions of a QR Code by its unique identifier
 */
const getCodesByCodeIdVersions = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/versions',
        ...options
    });
};
exports.getCodesByCodeIdVersions = getCodesByCodeIdVersions;
/**
 * Restore QR Code Version
 * Restores a specific version of a QR Code as the current version
 */
const postCodesByCodeIdVersionByVersionRestore = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/version/{version}/restore',
        ...options
    });
};
exports.postCodesByCodeIdVersionByVersionRestore = postCodesByCodeIdVersionByVersionRestore;
/**
 * Get QR Code Version File Content
 * Retrieves the file content of a specific QR Code version
 */
const getCodesByCodeIdVersionByVersionByType = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/version/{version}/{type}',
        ...options
    });
};
exports.getCodesByCodeIdVersionByVersionByType = getCodesByCodeIdVersionByVersionByType;
/**
 * Get QR Code Version Link
 * Retrieves a link to the file representation of a specific QR Code version
 */
const getCodesByCodeIdVersionByVersionByTypeLink = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/version/{version}/{type}/link',
        ...options
    });
};
exports.getCodesByCodeIdVersionByVersionByTypeLink = getCodesByCodeIdVersionByVersionByTypeLink;
/**
 * Delete QR Code version links
 * Deletes all QR Code version links for a specific version of a QR Code
 */
const deleteCodesByCodeIdVersionsByVersionLinks = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/versions/{version}/links',
        ...options
    });
};
exports.deleteCodesByCodeIdVersionsByVersionLinks = deleteCodesByCodeIdVersionsByVersionLinks;
/**
 * Delete QR Code version link by Type
 * Deletes a specific QR Code version link for a specific version of a QR Code
 */
const deleteCodesByCodeIdVersionsByVersionLinksByType = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/versions/{version}/links/{type}',
        ...options
    });
};
exports.deleteCodesByCodeIdVersionsByVersionLinksByType = deleteCodesByCodeIdVersionsByVersionLinksByType;
/**
 * Delete All QR Code Versions Links
 * Deletes all file links for all versions of a QR Code
 */
const deleteCodesByCodeIdVersionsLinks = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/versions/links',
        ...options
    });
};
exports.deleteCodesByCodeIdVersionsLinks = deleteCodesByCodeIdVersionsLinks;
/**
 * Delete All QR Code Versions Links by Type
 * Deletes a specific file type link for all versions of a QR Code
 */
const deleteCodesByCodeIdVersionsLinksByType = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/versions/links/{type}',
        ...options
    });
};
exports.deleteCodesByCodeIdVersionsLinksByType = deleteCodesByCodeIdVersionsLinksByType;
/**
 * Get QR Code File Content (SVG, PNG, PDF)
 * Retrieves the SVG, PNG, or PDF representation of a QR Code
 */
const getCodesByCodeIdByType = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/{type}',
        ...options
    });
};
exports.getCodesByCodeIdByType = getCodesByCodeIdByType;
/**
 * Get QR Code link
 * Retrieves a link to the SVG, PNG, or PDF representation of a QR Code
 */
const getCodesByCodeIdByTypeLink = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/{type}/link',
        ...options
    });
};
exports.getCodesByCodeIdByTypeLink = getCodesByCodeIdByTypeLink;
/**
 * Delete QR Code links
 * Deletes all links for the current version of a QR Code
 */
const deleteCodesByCodeIdLinks = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/links',
        ...options
    });
};
exports.deleteCodesByCodeIdLinks = deleteCodesByCodeIdLinks;
/**
 * Delete QR Code link by Type
 * Deletes a specific file type link for the current version of a QR Code
 */
const deleteCodesByCodeIdLinksByType = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codes/{codeId}/links/{type}',
        ...options
    });
};
exports.deleteCodesByCodeIdLinksByType = deleteCodesByCodeIdLinksByType;
/**
 * List all templates
 * Retrieves all templates available to the user, grouped by organization and workspace.
 */
const getTemplates = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates',
        ...options
    });
};
exports.getTemplates = getTemplates;
/**
 * Create a new template
 * Creates a new QR code template for an organization or workspace.
 */
const postTemplates = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postTemplates = postTemplates;
/**
 * List base templates
 * Retrieves all base templates from the QRCodeJs library with optional name filtering.
 */
const getTemplatesBase = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates/base',
        ...options
    });
};
exports.getTemplatesBase = getTemplatesBase;
/**
 * Delete template by ID
 * Deletes a template by its unique identifier. Fails if the template is used by codes.
 */
const deleteTemplatesByTemplateId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates/{templateId}',
        ...options
    });
};
exports.deleteTemplatesByTemplateId = deleteTemplatesByTemplateId;
/**
 * Get template by ID
 * Retrieves a template by its unique identifier.
 */
const getTemplatesByTemplateId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates/{templateId}',
        ...options
    });
};
exports.getTemplatesByTemplateId = getTemplatesByTemplateId;
/**
 * Update template by ID
 * Updates a template by its unique identifier.
 */
const putTemplatesByTemplateId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates/{templateId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putTemplatesByTemplateId = putTemplatesByTemplateId;
/**
 * Partially update template options by ID
 * Partially updates a template options by its unique identifier using a deep merge. Use null to delete a field.
 */
const putTemplatesByTemplateIdOptions = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates/{templateId}/options',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putTemplatesByTemplateIdOptions = putTemplatesByTemplateIdOptions;
/**
 * List templates for a workspace
 * Retrieves all templates for a specific workspace.
 */
const getTemplatesWorkspaceByWorkspaceId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/templates/workspace/{workspaceId}',
        ...options
    });
};
exports.getTemplatesWorkspaceByWorkspaceId = getTemplatesWorkspaceByWorkspaceId;
/**
 * List all styles
 * Retrieves all styles available to the user.
 */
const getStyles = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles',
        ...options
    });
};
exports.getStyles = getStyles;
/**
 * Create a new style
 * Creates a new style for an organization or workspace.
 */
const postStyles = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postStyles = postStyles;
/**
 * List base styles
 * Retrieves all base styles from the QRCodeJs library with optional name filtering.
 */
const getStylesBase = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles/base',
        ...options
    });
};
exports.getStylesBase = getStylesBase;
/**
 * Delete style by ID
 * Deletes a style by its unique identifier. Fails if the style is used by codes.
 */
const deleteStylesByStyleId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles/{styleId}',
        ...options
    });
};
exports.deleteStylesByStyleId = deleteStylesByStyleId;
/**
 * Get style by ID
 * Retrieves a style by its unique identifier.
 */
const getStylesByStyleId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles/{styleId}',
        ...options
    });
};
exports.getStylesByStyleId = getStylesByStyleId;
/**
 * Update style by ID
 * Updates a style by its unique identifier.
 */
const putStylesByStyleId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles/{styleId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putStylesByStyleId = putStylesByStyleId;
/**
 * Partially update style options by ID
 * Partially updates a style options by its unique identifier using a deep merge. Use null to delete a field.
 */
const putStylesByStyleIdOptions = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles/{styleId}/options',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putStylesByStyleIdOptions = putStylesByStyleIdOptions;
/**
 * List styles for a workspace
 * Retrieves all styles for a specific workspace.
 */
const getStylesWorkspaceByWorkspaceId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/styles/workspace/{workspaceId}',
        ...options
    });
};
exports.getStylesWorkspaceByWorkspaceId = getStylesWorkspaceByWorkspaceId;
/**
 * List all texts
 * Retrieves all texts available to the user.
 */
const getTexts = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts',
        ...options
    });
};
exports.getTexts = getTexts;
/**
 * Create a new text
 * Creates a new text for an organization or workspace.
 */
const postTexts = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postTexts = postTexts;
/**
 * List base texts
 * Retrieves all base text templates from the QRCodeJs library with optional name filtering.
 */
const getTextsBase = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts/base',
        ...options
    });
};
exports.getTextsBase = getTextsBase;
/**
 * Delete text by ID
 * Deletes a text by its unique identifier. Fails if the text is used by codes.
 */
const deleteTextsByTextId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts/{textId}',
        ...options
    });
};
exports.deleteTextsByTextId = deleteTextsByTextId;
/**
 * Get text by ID
 * Retrieves a text by its unique identifier.
 */
const getTextsByTextId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts/{textId}',
        ...options
    });
};
exports.getTextsByTextId = getTextsByTextId;
/**
 * Update text by ID
 * Updates a text by its unique identifier.
 */
const putTextsByTextId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts/{textId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putTextsByTextId = putTextsByTextId;
/**
 * Partially update text options by ID
 * Partially updates a text options by its unique identifier using a deep merge. Use null to delete a field.
 */
const putTextsByTextIdOptions = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts/{textId}/options',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putTextsByTextIdOptions = putTextsByTextIdOptions;
/**
 * List texts for a workspace
 * Retrieves all texts for a specific workspace.
 */
const getTextsWorkspaceByWorkspaceId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/texts/workspace/{workspaceId}',
        ...options
    });
};
exports.getTextsWorkspaceByWorkspaceId = getTextsWorkspaceByWorkspaceId;
/**
 * List all borders
 * Retrieves all borders available to the user.
 */
const getBorders = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders',
        ...options
    });
};
exports.getBorders = getBorders;
/**
 * Create a new border
 * Creates a new border for an organization or workspace.
 */
const postBorders = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postBorders = postBorders;
/**
 * List base borders
 * Retrieves all base border templates from the QRCodeJs library with optional name filtering.
 */
const getBordersBase = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders/base',
        ...options
    });
};
exports.getBordersBase = getBordersBase;
/**
 * Delete border by ID
 * Deletes a border by its unique identifier.
 */
const deleteBordersByBorderId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders/{borderId}',
        ...options
    });
};
exports.deleteBordersByBorderId = deleteBordersByBorderId;
/**
 * Get border by ID
 * Retrieves a border by its unique identifier.
 */
const getBordersByBorderId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders/{borderId}',
        ...options
    });
};
exports.getBordersByBorderId = getBordersByBorderId;
/**
 * Update border by ID
 * Updates a border by its unique identifier.
 */
const putBordersByBorderId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders/{borderId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putBordersByBorderId = putBordersByBorderId;
/**
 * Partially update border options by ID
 * Partially updates border options by its unique identifier using a deep merge. Use null to delete a field.
 */
const putBordersByBorderIdOptions = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders/{borderId}/options',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putBordersByBorderIdOptions = putBordersByBorderIdOptions;
/**
 * List borders for a workspace
 * Retrieves all borders for a specific workspace.
 */
const getBordersWorkspaceByWorkspaceId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/borders/workspace/{workspaceId}',
        ...options
    });
};
exports.getBordersWorkspaceByWorkspaceId = getBordersWorkspaceByWorkspaceId;
/**
 * List All Country Codes
 * Retrieves a list of all available country codes with their names and full names
 */
const getCountryCodes = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/country-codes',
        ...options
    });
};
exports.getCountryCodes = getCountryCodes;
/**
 * List Router Rule Templates
 * Retrieves available router rule templates based on user access. Returns global templates (if includeGlobal=true), organization-level templates, and workspace-specific templates the user has access to.
 */
const getRouterRuleTemplates = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/router-rule-templates',
        ...options
    });
};
exports.getRouterRuleTemplates = getRouterRuleTemplates;
/**
 * Create Router Rule Template
 * Creates a new router rule template. The template can be organization-level (no workspaceId) or workspace-specific. Template names must be unique within the organization scope.
 */
const postRouterRuleTemplates = (options) => {
    return (options?.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/router-rule-templates',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};
exports.postRouterRuleTemplates = postRouterRuleTemplates;
/**
 * Delete Router Rule Template
 * Deletes a router rule template. Templates that are currently being used by router rules cannot be deleted. Only organization templates can be deleted (not global templates).
 */
const deleteRouterRuleTemplatesByRouterRuleTemplateId = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/router-rule-templates/{routerRuleTemplateId}',
        ...options
    });
};
exports.deleteRouterRuleTemplatesByRouterRuleTemplateId = deleteRouterRuleTemplatesByRouterRuleTemplateId;
/**
 * Get Router Rule Template
 * Retrieves a specific router rule template by ID. Returns global templates and organization templates the user has access to.
 */
const getRouterRuleTemplatesByRouterRuleTemplateId = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/router-rule-templates/{routerRuleTemplateId}',
        ...options
    });
};
exports.getRouterRuleTemplatesByRouterRuleTemplateId = getRouterRuleTemplatesByRouterRuleTemplateId;
/**
 * Update Router Rule Template
 * Updates a router rule template. Only organization templates can be updated (not global templates). Users can only update templates within their organization.
 */
const putRouterRuleTemplatesByRouterRuleTemplateId = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/router-rule-templates/{routerRuleTemplateId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.putRouterRuleTemplatesByRouterRuleTemplateId = putRouterRuleTemplatesByRouterRuleTemplateId;
/**
 * List Organization Router Rules
 * Retrieves all router rules across the organization. Users with organization-level access see all rules, while workspace-limited users see only rules from their permitted workspaces.
 */
const getRouterRules = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/router-rules',
        ...options
    });
};
exports.getRouterRules = getRouterRules;
/**
 * List Workspace Router Rule Assignments
 * Retrieves all router rule assignments within a specific workspace with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data and QR code context.
 */
const getWorkspacesByWorkspaceIdRouterRules = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/router-rules',
        ...options
    });
};
exports.getWorkspacesByWorkspaceIdRouterRules = getWorkspacesByWorkspaceIdRouterRules;
/**
 * Create Workspace Router Rule Template
 * Creates a new router rule template scoped to the specified workspace. Template names must be unique within the organization scope. The workspaceId from the URL path will be used to scope the template.
 */
const postWorkspacesByWorkspaceIdRouterRuleTemplates = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/workspaces/{workspaceId}/router-rule-templates',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
exports.postWorkspacesByWorkspaceIdRouterRuleTemplates = postWorkspacesByWorkspaceIdRouterRuleTemplates;
