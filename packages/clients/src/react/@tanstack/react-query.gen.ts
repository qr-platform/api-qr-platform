// This file is auto-generated by @hey-api/openapi-ts

import { type Options, postAuthRegister, postAuthRegisterVerify, postAuthRegisterVerifyResend, postAuthSignIn, postAuthSignInVerify, postAuthEmailVerifySend, postAuthEmailVerify, getAuthMe, getAuthSignOut, postAuthPasswordReset, postAuthPasswordResetVerify, postAuthPasswordChange, getApiKeys, postApiKeys, deleteApiKeysByApiKeyId, getApiKeysByApiKeyId, putApiKeysByApiKeyId, putApiKeysByApiKeyIdStatus, getOrgsCurrent, putOrgs, postOrgsFirst, postOrgsCurrentByOrgId, getInvites, postInvites, getInvitesMe, deleteInvitesByInvitationId, getInvitesByTokenAccept, getInvitesByTokenDecline, getMembers, postMembers, deleteMembersByUserId, getMembersByUserIdRoles, postMembersByUserIdRole, deleteMembersByUserIdRoleByRoleName, getWorkspaces, postWorkspaces, deleteWorkspacesByWorkspaceId, getWorkspacesByWorkspaceId, putWorkspacesByWorkspaceId, deleteWorkspacesByWorkspaceIdMembersByUserIdRole, getWorkspacesByWorkspaceIdMembersByUserIdRole, postWorkspacesByWorkspaceIdMembersByUserIdRole, getWorkspacesByWorkspaceIdMembers, getRoles, getPlans, getPlansCurrent, getSettings, getSettingsCustom, postSettingsCustom, deleteSettingsCustomBySettingSlug, getSettingsCustomBySettingSlug, putSettingsCustomBySettingSlug, getSettingsCustomBySettingSlugValue, getSettingsService, getSettingsServiceBySettingSlug, putSettingsServiceBySettingSlug, getSettingsServiceBySettingSlugValue, getWorkspacesByWorkspaceIdSettings, getWorkspacesByWorkspaceIdSettingsCustom, postWorkspacesByWorkspaceIdSettingsCustom, deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlug, getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug, putWorkspacesByWorkspaceIdSettingsCustomBySettingSlug, getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue, getWorkspacesByWorkspaceIdSettingsService, deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlug, getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug, putWorkspacesByWorkspaceIdSettingsServiceBySettingSlug, getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue, getCodesByCodeIdScans, getCodesByCodeIdRouterRules, postCodesByCodeIdRouterRules, deleteCodesByCodeIdRouterRulesByRouterRuleId, getCodesByCodeIdRouterRulesByRouterRuleId, putCodesByCodeIdRouterRulesByRouterRuleId, getCodesDeleted, getCodesLinks, deleteCodesByCodeId, getCodesByCodeId, putCodesByCodeId, deleteCodes, getCodes, postCodes, putCodesByCodeIdOptions, deleteCodesPermanent, deleteCodesByCodeIdPermanent, postCodesByCodeIdRestore, postCodesBulkGet, postCodesGenerateByType, postCodesValidate, postCodesByCodeIdValidate, postCodesLinksRefresh, getCodesByCodeIdVersionByVersion, deleteCodesByCodeIdVersions, getCodesByCodeIdVersions, postCodesByCodeIdVersionByVersionRestore, getCodesByCodeIdVersionByVersionByType, getCodesByCodeIdVersionByVersionByTypeLink, deleteCodesByCodeIdVersionsByVersionLinks, deleteCodesByCodeIdVersionsByVersionLinksByType, deleteCodesByCodeIdVersionsLinks, deleteCodesByCodeIdVersionsLinksByType, getCodesByCodeIdByType, getCodesByCodeIdByTypeLink, deleteCodesByCodeIdLinks, deleteCodesByCodeIdLinksByType, getTemplates, postTemplates, getTemplatesBase, deleteTemplatesByTemplateId, getTemplatesByTemplateId, putTemplatesByTemplateId, putTemplatesByTemplateIdOptions, getTemplatesWorkspaceByWorkspaceId, getStyles, postStyles, getStylesBase, deleteStylesByStyleId, getStylesByStyleId, putStylesByStyleId, putStylesByStyleIdOptions, getStylesWorkspaceByWorkspaceId, getTexts, postTexts, getTextsBase, deleteTextsByTextId, getTextsByTextId, putTextsByTextId, putTextsByTextIdOptions, getTextsWorkspaceByWorkspaceId, getBorders, postBorders, getBordersBase, deleteBordersByBorderId, getBordersByBorderId, putBordersByBorderId, putBordersByBorderIdOptions, getBordersWorkspaceByWorkspaceId, getCountryCodes, getRouterRuleTemplates, postRouterRuleTemplates, deleteRouterRuleTemplatesByRouterRuleTemplateId, getRouterRuleTemplatesByRouterRuleTemplateId, putRouterRuleTemplatesByRouterRuleTemplateId, getRouterRules, getWorkspacesByWorkspaceIdRouterRules, postWorkspacesByWorkspaceIdRouterRuleTemplates } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { PostAuthRegisterData, PostAuthRegisterError, PostAuthRegisterResponse, PostAuthRegisterVerifyData, PostAuthRegisterVerifyError, PostAuthRegisterVerifyResponse, PostAuthRegisterVerifyResendData, PostAuthRegisterVerifyResendError, PostAuthRegisterVerifyResendResponse, PostAuthSignInData, PostAuthSignInError, PostAuthSignInResponse, PostAuthSignInVerifyData, PostAuthSignInVerifyError, PostAuthSignInVerifyResponse, PostAuthEmailVerifySendData, PostAuthEmailVerifySendError, PostAuthEmailVerifySendResponse, PostAuthEmailVerifyData, PostAuthEmailVerifyError, PostAuthEmailVerifyResponse, GetAuthMeData, GetAuthSignOutData, PostAuthPasswordResetData, PostAuthPasswordResetError, PostAuthPasswordResetResponse, PostAuthPasswordResetVerifyData, PostAuthPasswordResetVerifyError, PostAuthPasswordResetVerifyResponse, PostAuthPasswordChangeData, PostAuthPasswordChangeError, PostAuthPasswordChangeResponse, GetApiKeysData, PostApiKeysData, PostApiKeysError, PostApiKeysResponse, DeleteApiKeysByApiKeyIdData, DeleteApiKeysByApiKeyIdError, DeleteApiKeysByApiKeyIdResponse, GetApiKeysByApiKeyIdData, PutApiKeysByApiKeyIdData, PutApiKeysByApiKeyIdError, PutApiKeysByApiKeyIdResponse, PutApiKeysByApiKeyIdStatusData, PutApiKeysByApiKeyIdStatusError, PutApiKeysByApiKeyIdStatusResponse, GetOrgsCurrentData, PutOrgsData, PutOrgsError, PutOrgsResponse, PostOrgsFirstData, PostOrgsFirstError, PostOrgsFirstResponse, PostOrgsCurrentByOrgIdData, PostOrgsCurrentByOrgIdError, PostOrgsCurrentByOrgIdResponse, GetInvitesData, PostInvitesData, PostInvitesError, PostInvitesResponse, GetInvitesMeData, DeleteInvitesByInvitationIdData, DeleteInvitesByInvitationIdError, DeleteInvitesByInvitationIdResponse, GetInvitesByTokenAcceptData, GetInvitesByTokenDeclineData, GetMembersData, PostMembersData, PostMembersError, PostMembersResponse, DeleteMembersByUserIdData, DeleteMembersByUserIdError, DeleteMembersByUserIdResponse, GetMembersByUserIdRolesData, PostMembersByUserIdRoleData, PostMembersByUserIdRoleError, PostMembersByUserIdRoleResponse, DeleteMembersByUserIdRoleByRoleNameData, DeleteMembersByUserIdRoleByRoleNameError, DeleteMembersByUserIdRoleByRoleNameResponse, GetWorkspacesData, PostWorkspacesData, PostWorkspacesError, PostWorkspacesResponse, DeleteWorkspacesByWorkspaceIdData, DeleteWorkspacesByWorkspaceIdError, DeleteWorkspacesByWorkspaceIdResponse, GetWorkspacesByWorkspaceIdData, PutWorkspacesByWorkspaceIdData, PutWorkspacesByWorkspaceIdError, PutWorkspacesByWorkspaceIdResponse, DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleData, DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleError, DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, GetWorkspacesByWorkspaceIdMembersByUserIdRoleData, PostWorkspacesByWorkspaceIdMembersByUserIdRoleData, PostWorkspacesByWorkspaceIdMembersByUserIdRoleError, PostWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, GetWorkspacesByWorkspaceIdMembersData, GetRolesData, GetPlansData, GetPlansCurrentData, GetSettingsData, GetSettingsCustomData, PostSettingsCustomData, PostSettingsCustomError, PostSettingsCustomResponse, DeleteSettingsCustomBySettingSlugData, DeleteSettingsCustomBySettingSlugError, DeleteSettingsCustomBySettingSlugResponse, GetSettingsCustomBySettingSlugData, PutSettingsCustomBySettingSlugData, PutSettingsCustomBySettingSlugError, PutSettingsCustomBySettingSlugResponse, GetSettingsCustomBySettingSlugValueData, GetSettingsServiceData, GetSettingsServiceBySettingSlugData, PutSettingsServiceBySettingSlugData, PutSettingsServiceBySettingSlugError, PutSettingsServiceBySettingSlugResponse, GetSettingsServiceBySettingSlugValueData, GetWorkspacesByWorkspaceIdSettingsData, GetWorkspacesByWorkspaceIdSettingsCustomData, PostWorkspacesByWorkspaceIdSettingsCustomData, PostWorkspacesByWorkspaceIdSettingsCustomError, PostWorkspacesByWorkspaceIdSettingsCustomResponse, DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData, DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugError, DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData, PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData, PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugError, PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueData, GetWorkspacesByWorkspaceIdSettingsServiceData, DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData, DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugError, DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData, PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData, PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugError, PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueData, GetCodesByCodeIdScansData, GetCodesByCodeIdScansError, GetCodesByCodeIdRouterRulesData, GetCodesByCodeIdRouterRulesError, GetCodesByCodeIdRouterRulesResponse, PostCodesByCodeIdRouterRulesData, PostCodesByCodeIdRouterRulesError, PostCodesByCodeIdRouterRulesResponse, DeleteCodesByCodeIdRouterRulesByRouterRuleIdData, DeleteCodesByCodeIdRouterRulesByRouterRuleIdError, DeleteCodesByCodeIdRouterRulesByRouterRuleIdResponse, GetCodesByCodeIdRouterRulesByRouterRuleIdData, PutCodesByCodeIdRouterRulesByRouterRuleIdData, PutCodesByCodeIdRouterRulesByRouterRuleIdError, PutCodesByCodeIdRouterRulesByRouterRuleIdResponse, GetCodesDeletedData, GetCodesDeletedError, GetCodesDeletedResponse, GetCodesLinksData, GetCodesLinksError, GetCodesLinksResponse, DeleteCodesByCodeIdData, DeleteCodesByCodeIdError, DeleteCodesByCodeIdResponse, GetCodesByCodeIdData, PutCodesByCodeIdData, PutCodesByCodeIdError, PutCodesByCodeIdResponse, DeleteCodesData, DeleteCodesError, DeleteCodesResponse, GetCodesData, GetCodesError, GetCodesResponse, PostCodesData, PostCodesError, PostCodesResponse, PutCodesByCodeIdOptionsData, PutCodesByCodeIdOptionsError, PutCodesByCodeIdOptionsResponse, DeleteCodesPermanentData, DeleteCodesPermanentError, DeleteCodesPermanentResponse, DeleteCodesByCodeIdPermanentData, DeleteCodesByCodeIdPermanentError, DeleteCodesByCodeIdPermanentResponse, PostCodesByCodeIdRestoreData, PostCodesByCodeIdRestoreError, PostCodesByCodeIdRestoreResponse, PostCodesBulkGetData, PostCodesBulkGetError, PostCodesBulkGetResponse, PostCodesGenerateByTypeData, PostCodesGenerateByTypeError, PostCodesGenerateByTypeResponse, PostCodesValidateData, PostCodesValidateError, PostCodesValidateResponse, PostCodesByCodeIdValidateData, PostCodesByCodeIdValidateError, PostCodesByCodeIdValidateResponse, PostCodesLinksRefreshData, PostCodesLinksRefreshError, PostCodesLinksRefreshResponse, GetCodesByCodeIdVersionByVersionData, DeleteCodesByCodeIdVersionsData, DeleteCodesByCodeIdVersionsError, DeleteCodesByCodeIdVersionsResponse, GetCodesByCodeIdVersionsData, PostCodesByCodeIdVersionByVersionRestoreData, PostCodesByCodeIdVersionByVersionRestoreError, PostCodesByCodeIdVersionByVersionRestoreResponse, GetCodesByCodeIdVersionByVersionByTypeData, GetCodesByCodeIdVersionByVersionByTypeLinkData, DeleteCodesByCodeIdVersionsByVersionLinksData, DeleteCodesByCodeIdVersionsByVersionLinksError, DeleteCodesByCodeIdVersionsByVersionLinksResponse, DeleteCodesByCodeIdVersionsByVersionLinksByTypeData, DeleteCodesByCodeIdVersionsByVersionLinksByTypeError, DeleteCodesByCodeIdVersionsByVersionLinksByTypeResponse, DeleteCodesByCodeIdVersionsLinksData, DeleteCodesByCodeIdVersionsLinksError, DeleteCodesByCodeIdVersionsLinksResponse, DeleteCodesByCodeIdVersionsLinksByTypeData, DeleteCodesByCodeIdVersionsLinksByTypeError, DeleteCodesByCodeIdVersionsLinksByTypeResponse, GetCodesByCodeIdByTypeData, GetCodesByCodeIdByTypeLinkData, DeleteCodesByCodeIdLinksData, DeleteCodesByCodeIdLinksError, DeleteCodesByCodeIdLinksResponse, DeleteCodesByCodeIdLinksByTypeData, DeleteCodesByCodeIdLinksByTypeError, DeleteCodesByCodeIdLinksByTypeResponse, GetTemplatesData, PostTemplatesData, PostTemplatesError, PostTemplatesResponse, GetTemplatesBaseData, DeleteTemplatesByTemplateIdData, DeleteTemplatesByTemplateIdError, DeleteTemplatesByTemplateIdResponse, GetTemplatesByTemplateIdData, PutTemplatesByTemplateIdData, PutTemplatesByTemplateIdError, PutTemplatesByTemplateIdResponse, PutTemplatesByTemplateIdOptionsData, PutTemplatesByTemplateIdOptionsError, PutTemplatesByTemplateIdOptionsResponse, GetTemplatesWorkspaceByWorkspaceIdData, GetStylesData, PostStylesData, PostStylesError, PostStylesResponse, GetStylesBaseData, DeleteStylesByStyleIdData, DeleteStylesByStyleIdError, DeleteStylesByStyleIdResponse, GetStylesByStyleIdData, PutStylesByStyleIdData, PutStylesByStyleIdError, PutStylesByStyleIdResponse, PutStylesByStyleIdOptionsData, PutStylesByStyleIdOptionsError, PutStylesByStyleIdOptionsResponse, GetStylesWorkspaceByWorkspaceIdData, GetTextsData, PostTextsData, PostTextsError, PostTextsResponse, GetTextsBaseData, DeleteTextsByTextIdData, DeleteTextsByTextIdError, DeleteTextsByTextIdResponse, GetTextsByTextIdData, PutTextsByTextIdData, PutTextsByTextIdError, PutTextsByTextIdResponse, PutTextsByTextIdOptionsData, PutTextsByTextIdOptionsError, PutTextsByTextIdOptionsResponse, GetTextsWorkspaceByWorkspaceIdData, GetBordersData, PostBordersData, PostBordersError, PostBordersResponse, GetBordersBaseData, DeleteBordersByBorderIdData, DeleteBordersByBorderIdError, DeleteBordersByBorderIdResponse, GetBordersByBorderIdData, PutBordersByBorderIdData, PutBordersByBorderIdError, PutBordersByBorderIdResponse, PutBordersByBorderIdOptionsData, PutBordersByBorderIdOptionsError, PutBordersByBorderIdOptionsResponse, GetBordersWorkspaceByWorkspaceIdData, GetCountryCodesData, GetRouterRuleTemplatesData, GetRouterRuleTemplatesError, PostRouterRuleTemplatesData, PostRouterRuleTemplatesError, DeleteRouterRuleTemplatesByRouterRuleTemplateIdData, DeleteRouterRuleTemplatesByRouterRuleTemplateIdError, DeleteRouterRuleTemplatesByRouterRuleTemplateIdResponse, GetRouterRuleTemplatesByRouterRuleTemplateIdData, PutRouterRuleTemplatesByRouterRuleTemplateIdData, PutRouterRuleTemplatesByRouterRuleTemplateIdError, GetRouterRulesData, GetRouterRulesError, GetRouterRulesResponse, GetWorkspacesByWorkspaceIdRouterRulesData, GetWorkspacesByWorkspaceIdRouterRulesError, GetWorkspacesByWorkspaceIdRouterRulesResponse, PostWorkspacesByWorkspaceIdRouterRuleTemplatesData, PostWorkspacesByWorkspaceIdRouterRuleTemplatesError } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const postAuthRegisterQueryKey = (options?: Options<PostAuthRegisterData>) => createQueryKey('postAuthRegister', options);

/**
 * Register New User
 * Registers a new user and organization. Sends a verification code and token via email
 */
export const postAuthRegisterOptions = (options?: Options<PostAuthRegisterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthRegister({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthRegisterQueryKey(options)
    });
};

/**
 * Register New User
 * Registers a new user and organization. Sends a verification code and token via email
 */
export const postAuthRegisterMutation = (options?: Partial<Options<PostAuthRegisterData>>): UseMutationOptions<PostAuthRegisterResponse, PostAuthRegisterError, Options<PostAuthRegisterData>> => {
    const mutationOptions: UseMutationOptions<PostAuthRegisterResponse, PostAuthRegisterError, Options<PostAuthRegisterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthRegister({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthRegisterVerifyQueryKey = (options?: Options<PostAuthRegisterVerifyData>) => createQueryKey('postAuthRegisterVerify', options);

/**
 * Verify Registration Code or Token
 * Verifies the 6-digit code or token sent via email after registration
 */
export const postAuthRegisterVerifyOptions = (options?: Options<PostAuthRegisterVerifyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthRegisterVerify({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthRegisterVerifyQueryKey(options)
    });
};

/**
 * Verify Registration Code or Token
 * Verifies the 6-digit code or token sent via email after registration
 */
export const postAuthRegisterVerifyMutation = (options?: Partial<Options<PostAuthRegisterVerifyData>>): UseMutationOptions<PostAuthRegisterVerifyResponse, PostAuthRegisterVerifyError, Options<PostAuthRegisterVerifyData>> => {
    const mutationOptions: UseMutationOptions<PostAuthRegisterVerifyResponse, PostAuthRegisterVerifyError, Options<PostAuthRegisterVerifyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthRegisterVerify({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthRegisterVerifyResendQueryKey = (options?: Options<PostAuthRegisterVerifyResendData>) => createQueryKey('postAuthRegisterVerifyResend', options);

/**
 * Resend Registration Verification Code and Token
 * Resends the 6-digit verification code or token to the user's email.
 */
export const postAuthRegisterVerifyResendOptions = (options?: Options<PostAuthRegisterVerifyResendData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthRegisterVerifyResend({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthRegisterVerifyResendQueryKey(options)
    });
};

/**
 * Resend Registration Verification Code and Token
 * Resends the 6-digit verification code or token to the user's email.
 */
export const postAuthRegisterVerifyResendMutation = (options?: Partial<Options<PostAuthRegisterVerifyResendData>>): UseMutationOptions<PostAuthRegisterVerifyResendResponse, PostAuthRegisterVerifyResendError, Options<PostAuthRegisterVerifyResendData>> => {
    const mutationOptions: UseMutationOptions<PostAuthRegisterVerifyResendResponse, PostAuthRegisterVerifyResendError, Options<PostAuthRegisterVerifyResendData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthRegisterVerifyResend({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthSignInQueryKey = (options?: Options<PostAuthSignInData>) => createQueryKey('postAuthSignIn', options);

/**
 * Sign In User
 * Initiates user sign-in. Returns an access token if password is provided and correct, otherwise indicates if passwordless verification is needed
 */
export const postAuthSignInOptions = (options?: Options<PostAuthSignInData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthSignIn({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthSignInQueryKey(options)
    });
};

/**
 * Sign In User
 * Initiates user sign-in. Returns an access token if password is provided and correct, otherwise indicates if passwordless verification is needed
 */
export const postAuthSignInMutation = (options?: Partial<Options<PostAuthSignInData>>): UseMutationOptions<PostAuthSignInResponse, PostAuthSignInError, Options<PostAuthSignInData>> => {
    const mutationOptions: UseMutationOptions<PostAuthSignInResponse, PostAuthSignInError, Options<PostAuthSignInData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthSignIn({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthSignInVerifyQueryKey = (options?: Options<PostAuthSignInVerifyData>) => createQueryKey('postAuthSignInVerify', options);

/**
 * Verify Sign In Code or Token
 * Verifies the 6-digit code or token sent via email for passwordless sign-in
 */
export const postAuthSignInVerifyOptions = (options?: Options<PostAuthSignInVerifyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthSignInVerify({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthSignInVerifyQueryKey(options)
    });
};

/**
 * Verify Sign In Code or Token
 * Verifies the 6-digit code or token sent via email for passwordless sign-in
 */
export const postAuthSignInVerifyMutation = (options?: Partial<Options<PostAuthSignInVerifyData>>): UseMutationOptions<PostAuthSignInVerifyResponse, PostAuthSignInVerifyError, Options<PostAuthSignInVerifyData>> => {
    const mutationOptions: UseMutationOptions<PostAuthSignInVerifyResponse, PostAuthSignInVerifyError, Options<PostAuthSignInVerifyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthSignInVerify({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthEmailVerifySendQueryKey = (options?: Options<PostAuthEmailVerifySendData>) => createQueryKey('postAuthEmailVerifySend', options);

/**
 * Send Email Verification Code and Token
 * Sends a verification code and token to the user's email if it's not already verified.
 */
export const postAuthEmailVerifySendOptions = (options?: Options<PostAuthEmailVerifySendData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthEmailVerifySend({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthEmailVerifySendQueryKey(options)
    });
};

/**
 * Send Email Verification Code and Token
 * Sends a verification code and token to the user's email if it's not already verified.
 */
export const postAuthEmailVerifySendMutation = (options?: Partial<Options<PostAuthEmailVerifySendData>>): UseMutationOptions<PostAuthEmailVerifySendResponse, PostAuthEmailVerifySendError, Options<PostAuthEmailVerifySendData>> => {
    const mutationOptions: UseMutationOptions<PostAuthEmailVerifySendResponse, PostAuthEmailVerifySendError, Options<PostAuthEmailVerifySendData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthEmailVerifySend({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthEmailVerifyQueryKey = (options?: Options<PostAuthEmailVerifyData>) => createQueryKey('postAuthEmailVerify', options);

/**
 * Verify Email Address
 * Verifies the user's email address using the provided code or token.
 */
export const postAuthEmailVerifyOptions = (options?: Options<PostAuthEmailVerifyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthEmailVerify({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthEmailVerifyQueryKey(options)
    });
};

/**
 * Verify Email Address
 * Verifies the user's email address using the provided code or token.
 */
export const postAuthEmailVerifyMutation = (options?: Partial<Options<PostAuthEmailVerifyData>>): UseMutationOptions<PostAuthEmailVerifyResponse, PostAuthEmailVerifyError, Options<PostAuthEmailVerifyData>> => {
    const mutationOptions: UseMutationOptions<PostAuthEmailVerifyResponse, PostAuthEmailVerifyError, Options<PostAuthEmailVerifyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthEmailVerify({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthMeQueryKey = (options?: Options<GetAuthMeData>) => createQueryKey('getAuthMe', options);

/**
 * Get Current User
 * Retrieves the details of the currently authenticated user
 */
export const getAuthMeOptions = (options?: Options<GetAuthMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuthMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthMeQueryKey(options)
    });
};

export const getAuthSignOutQueryKey = (options?: Options<GetAuthSignOutData>) => createQueryKey('getAuthSignOut', options);

/**
 * Sign Out User
 * Signs out the current user by clearing relevant cookies/session data
 */
export const getAuthSignOutOptions = (options?: Options<GetAuthSignOutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuthSignOut({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthSignOutQueryKey(options)
    });
};

export const postAuthPasswordResetQueryKey = (options?: Options<PostAuthPasswordResetData>) => createQueryKey('postAuthPasswordReset', options);

/**
 * Request Password Reset
 * Sends a password reset email with a verification token
 */
export const postAuthPasswordResetOptions = (options?: Options<PostAuthPasswordResetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthPasswordReset({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthPasswordResetQueryKey(options)
    });
};

/**
 * Request Password Reset
 * Sends a password reset email with a verification token
 */
export const postAuthPasswordResetMutation = (options?: Partial<Options<PostAuthPasswordResetData>>): UseMutationOptions<PostAuthPasswordResetResponse, PostAuthPasswordResetError, Options<PostAuthPasswordResetData>> => {
    const mutationOptions: UseMutationOptions<PostAuthPasswordResetResponse, PostAuthPasswordResetError, Options<PostAuthPasswordResetData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthPasswordReset({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthPasswordResetVerifyQueryKey = (options?: Options<PostAuthPasswordResetVerifyData>) => createQueryKey('postAuthPasswordResetVerify', options);

/**
 * Verify Password Reset
 * Verifies the password reset token and sets a new password
 */
export const postAuthPasswordResetVerifyOptions = (options?: Options<PostAuthPasswordResetVerifyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthPasswordResetVerify({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthPasswordResetVerifyQueryKey(options)
    });
};

/**
 * Verify Password Reset
 * Verifies the password reset token and sets a new password
 */
export const postAuthPasswordResetVerifyMutation = (options?: Partial<Options<PostAuthPasswordResetVerifyData>>): UseMutationOptions<PostAuthPasswordResetVerifyResponse, PostAuthPasswordResetVerifyError, Options<PostAuthPasswordResetVerifyData>> => {
    const mutationOptions: UseMutationOptions<PostAuthPasswordResetVerifyResponse, PostAuthPasswordResetVerifyError, Options<PostAuthPasswordResetVerifyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthPasswordResetVerify({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthPasswordChangeQueryKey = (options?: Options<PostAuthPasswordChangeData>) => createQueryKey('postAuthPasswordChange', options);

/**
 * Change Password
 * Changes the password for the authenticated user
 */
export const postAuthPasswordChangeOptions = (options?: Options<PostAuthPasswordChangeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthPasswordChange({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthPasswordChangeQueryKey(options)
    });
};

/**
 * Change Password
 * Changes the password for the authenticated user
 */
export const postAuthPasswordChangeMutation = (options?: Partial<Options<PostAuthPasswordChangeData>>): UseMutationOptions<PostAuthPasswordChangeResponse, PostAuthPasswordChangeError, Options<PostAuthPasswordChangeData>> => {
    const mutationOptions: UseMutationOptions<PostAuthPasswordChangeResponse, PostAuthPasswordChangeError, Options<PostAuthPasswordChangeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthPasswordChange({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeysQueryKey = (options?: Options<GetApiKeysData>) => createQueryKey('getApiKeys', options);

/**
 * List API keys
 * Retrieves all API keys for the current organization.
 */
export const getApiKeysOptions = (options?: Options<GetApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeysQueryKey(options)
    });
};

export const postApiKeysQueryKey = (options?: Options<PostApiKeysData>) => createQueryKey('postApiKeys', options);

/**
 * Create API key
 * Creates a new API key for the current organization.
 */
export const postApiKeysOptions = (options?: Options<PostApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postApiKeysQueryKey(options)
    });
};

/**
 * Create API key
 * Creates a new API key for the current organization.
 */
export const postApiKeysMutation = (options?: Partial<Options<PostApiKeysData>>): UseMutationOptions<PostApiKeysResponse, PostApiKeysError, Options<PostApiKeysData>> => {
    const mutationOptions: UseMutationOptions<PostApiKeysResponse, PostApiKeysError, Options<PostApiKeysData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postApiKeys({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete API key
 * Deletes an API key by its ID.
 */
export const deleteApiKeysByApiKeyIdMutation = (options?: Partial<Options<DeleteApiKeysByApiKeyIdData>>): UseMutationOptions<DeleteApiKeysByApiKeyIdResponse, DeleteApiKeysByApiKeyIdError, Options<DeleteApiKeysByApiKeyIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiKeysByApiKeyIdResponse, DeleteApiKeysByApiKeyIdError, Options<DeleteApiKeysByApiKeyIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteApiKeysByApiKeyId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeysByApiKeyIdQueryKey = (options: Options<GetApiKeysByApiKeyIdData>) => createQueryKey('getApiKeysByApiKeyId', options);

/**
 * Get API key details
 * Retrieves details of a specific API key by its ID.
 */
export const getApiKeysByApiKeyIdOptions = (options: Options<GetApiKeysByApiKeyIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKeysByApiKeyId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeysByApiKeyIdQueryKey(options)
    });
};

/**
 * Update API key
 * Updates an existing API key by its ID.
 */
export const putApiKeysByApiKeyIdMutation = (options?: Partial<Options<PutApiKeysByApiKeyIdData>>): UseMutationOptions<PutApiKeysByApiKeyIdResponse, PutApiKeysByApiKeyIdError, Options<PutApiKeysByApiKeyIdData>> => {
    const mutationOptions: UseMutationOptions<PutApiKeysByApiKeyIdResponse, PutApiKeysByApiKeyIdError, Options<PutApiKeysByApiKeyIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putApiKeysByApiKeyId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Change API key status
 * Changes the status of an API key (activate or disable).
 */
export const putApiKeysByApiKeyIdStatusMutation = (options?: Partial<Options<PutApiKeysByApiKeyIdStatusData>>): UseMutationOptions<PutApiKeysByApiKeyIdStatusResponse, PutApiKeysByApiKeyIdStatusError, Options<PutApiKeysByApiKeyIdStatusData>> => {
    const mutationOptions: UseMutationOptions<PutApiKeysByApiKeyIdStatusResponse, PutApiKeysByApiKeyIdStatusError, Options<PutApiKeysByApiKeyIdStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putApiKeysByApiKeyIdStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrgsCurrentQueryKey = (options?: Options<GetOrgsCurrentData>) => createQueryKey('getOrgsCurrent', options);

/**
 * Get current organization
 * Retrieves details of the current active organization for the authenticated user.
 */
export const getOrgsCurrentOptions = (options?: Options<GetOrgsCurrentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrgsCurrent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrgsCurrentQueryKey(options)
    });
};

/**
 * Update current organization
 * Updates the details of the current active organization.
 */
export const putOrgsMutation = (options?: Partial<Options<PutOrgsData>>): UseMutationOptions<PutOrgsResponse, PutOrgsError, Options<PutOrgsData>> => {
    const mutationOptions: UseMutationOptions<PutOrgsResponse, PutOrgsError, Options<PutOrgsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putOrgs({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postOrgsFirstQueryKey = (options?: Options<PostOrgsFirstData>) => createQueryKey('postOrgsFirst', options);

/**
 * Create first organization
 * Creates the first organization for a new user. Only works when the user has no organizations.
 */
export const postOrgsFirstOptions = (options?: Options<PostOrgsFirstData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOrgsFirst({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOrgsFirstQueryKey(options)
    });
};

/**
 * Create first organization
 * Creates the first organization for a new user. Only works when the user has no organizations.
 */
export const postOrgsFirstMutation = (options?: Partial<Options<PostOrgsFirstData>>): UseMutationOptions<PostOrgsFirstResponse, PostOrgsFirstError, Options<PostOrgsFirstData>> => {
    const mutationOptions: UseMutationOptions<PostOrgsFirstResponse, PostOrgsFirstError, Options<PostOrgsFirstData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOrgsFirst({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postOrgsCurrentByOrgIdQueryKey = (options: Options<PostOrgsCurrentByOrgIdData>) => createQueryKey('postOrgsCurrentByOrgId', options);

/**
 * Switch current organization
 * Switches the current active organization for the authenticated user.
 */
export const postOrgsCurrentByOrgIdOptions = (options: Options<PostOrgsCurrentByOrgIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOrgsCurrentByOrgId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOrgsCurrentByOrgIdQueryKey(options)
    });
};

/**
 * Switch current organization
 * Switches the current active organization for the authenticated user.
 */
export const postOrgsCurrentByOrgIdMutation = (options?: Partial<Options<PostOrgsCurrentByOrgIdData>>): UseMutationOptions<PostOrgsCurrentByOrgIdResponse, PostOrgsCurrentByOrgIdError, Options<PostOrgsCurrentByOrgIdData>> => {
    const mutationOptions: UseMutationOptions<PostOrgsCurrentByOrgIdResponse, PostOrgsCurrentByOrgIdError, Options<PostOrgsCurrentByOrgIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOrgsCurrentByOrgId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInvitesQueryKey = (options?: Options<GetInvitesData>) => createQueryKey('getInvites', options);

/**
 * List organization invitations
 * Retrieves all invitations for the current organization.
 */
export const getInvitesOptions = (options?: Options<GetInvitesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInvites({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInvitesQueryKey(options)
    });
};

export const postInvitesQueryKey = (options?: Options<PostInvitesData>) => createQueryKey('postInvites', options);

/**
 * Create invitation
 * Creates a new invitation to join the organization with a specified role.
 */
export const postInvitesOptions = (options?: Options<PostInvitesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postInvites({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postInvitesQueryKey(options)
    });
};

/**
 * Create invitation
 * Creates a new invitation to join the organization with a specified role.
 */
export const postInvitesMutation = (options?: Partial<Options<PostInvitesData>>): UseMutationOptions<PostInvitesResponse, PostInvitesError, Options<PostInvitesData>> => {
    const mutationOptions: UseMutationOptions<PostInvitesResponse, PostInvitesError, Options<PostInvitesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postInvites({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInvitesMeQueryKey = (options?: Options<GetInvitesMeData>) => createQueryKey('getInvitesMe', options);

/**
 * List my invitations
 * Retrieves all invitations sent by the current user.
 */
export const getInvitesMeOptions = (options?: Options<GetInvitesMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInvitesMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInvitesMeQueryKey(options)
    });
};

/**
 * Delete invitation
 * Deletes an invitation by its ID.
 */
export const deleteInvitesByInvitationIdMutation = (options?: Partial<Options<DeleteInvitesByInvitationIdData>>): UseMutationOptions<DeleteInvitesByInvitationIdResponse, DeleteInvitesByInvitationIdError, Options<DeleteInvitesByInvitationIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteInvitesByInvitationIdResponse, DeleteInvitesByInvitationIdError, Options<DeleteInvitesByInvitationIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteInvitesByInvitationId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInvitesByTokenAcceptQueryKey = (options: Options<GetInvitesByTokenAcceptData>) => createQueryKey('getInvitesByTokenAccept', options);

/**
 * Accept invitation
 * Accepts an invitation using the provided token. Creates a user account if needed.
 */
export const getInvitesByTokenAcceptOptions = (options: Options<GetInvitesByTokenAcceptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInvitesByTokenAccept({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInvitesByTokenAcceptQueryKey(options)
    });
};

export const getInvitesByTokenDeclineQueryKey = (options: Options<GetInvitesByTokenDeclineData>) => createQueryKey('getInvitesByTokenDecline', options);

/**
 * Decline invitation
 * Declines an invitation using the provided token.
 */
export const getInvitesByTokenDeclineOptions = (options: Options<GetInvitesByTokenDeclineData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInvitesByTokenDecline({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInvitesByTokenDeclineQueryKey(options)
    });
};

export const getMembersQueryKey = (options?: Options<GetMembersData>) => createQueryKey('getMembers', options);

/**
 * List organization members
 * Retrieves all members of the current organization.
 */
export const getMembersOptions = (options?: Options<GetMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersQueryKey(options)
    });
};

export const postMembersQueryKey = (options?: Options<PostMembersData>) => createQueryKey('postMembers', options);

/**
 * Add a member to organization
 * Adds a new member to the current organization with the specified role.
 */
export const postMembersOptions = (options?: Options<PostMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMembersQueryKey(options)
    });
};

/**
 * Add a member to organization
 * Adds a new member to the current organization with the specified role.
 */
export const postMembersMutation = (options?: Partial<Options<PostMembersData>>): UseMutationOptions<PostMembersResponse, PostMembersError, Options<PostMembersData>> => {
    const mutationOptions: UseMutationOptions<PostMembersResponse, PostMembersError, Options<PostMembersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMembers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove member from organization
 * Removes a member from the current organization.
 */
export const deleteMembersByUserIdMutation = (options?: Partial<Options<DeleteMembersByUserIdData>>): UseMutationOptions<DeleteMembersByUserIdResponse, DeleteMembersByUserIdError, Options<DeleteMembersByUserIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMembersByUserIdResponse, DeleteMembersByUserIdError, Options<DeleteMembersByUserIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMembersByUserId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembersByUserIdRolesQueryKey = (options: Options<GetMembersByUserIdRolesData>) => createQueryKey('getMembersByUserIdRoles', options);

/**
 * Get member roles
 * Retrieves all roles assigned to a member in the current organization.
 */
export const getMembersByUserIdRolesOptions = (options: Options<GetMembersByUserIdRolesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembersByUserIdRoles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersByUserIdRolesQueryKey(options)
    });
};

export const postMembersByUserIdRoleQueryKey = (options: Options<PostMembersByUserIdRoleData>) => createQueryKey('postMembersByUserIdRole', options);

/**
 * Add role to member
 * Assigns a new role to a member in the current organization.
 */
export const postMembersByUserIdRoleOptions = (options: Options<PostMembersByUserIdRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMembersByUserIdRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMembersByUserIdRoleQueryKey(options)
    });
};

/**
 * Add role to member
 * Assigns a new role to a member in the current organization.
 */
export const postMembersByUserIdRoleMutation = (options?: Partial<Options<PostMembersByUserIdRoleData>>): UseMutationOptions<PostMembersByUserIdRoleResponse, PostMembersByUserIdRoleError, Options<PostMembersByUserIdRoleData>> => {
    const mutationOptions: UseMutationOptions<PostMembersByUserIdRoleResponse, PostMembersByUserIdRoleError, Options<PostMembersByUserIdRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMembersByUserIdRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove role from member
 * Removes a role from a member in the current organization.
 */
export const deleteMembersByUserIdRoleByRoleNameMutation = (options?: Partial<Options<DeleteMembersByUserIdRoleByRoleNameData>>): UseMutationOptions<DeleteMembersByUserIdRoleByRoleNameResponse, DeleteMembersByUserIdRoleByRoleNameError, Options<DeleteMembersByUserIdRoleByRoleNameData>> => {
    const mutationOptions: UseMutationOptions<DeleteMembersByUserIdRoleByRoleNameResponse, DeleteMembersByUserIdRoleByRoleNameError, Options<DeleteMembersByUserIdRoleByRoleNameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMembersByUserIdRoleByRoleName({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesQueryKey = (options?: Options<GetWorkspacesData>) => createQueryKey('getWorkspaces', options);

/**
 * List workspaces
 * Retrieves all workspaces for the current organization.
 */
export const getWorkspacesOptions = (options?: Options<GetWorkspacesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspaces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesQueryKey(options)
    });
};

export const postWorkspacesQueryKey = (options?: Options<PostWorkspacesData>) => createQueryKey('postWorkspaces', options);

/**
 * Create a new workspace
 * Creates a new workspace in the current organization.
 */
export const postWorkspacesOptions = (options?: Options<PostWorkspacesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postWorkspaces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postWorkspacesQueryKey(options)
    });
};

/**
 * Create a new workspace
 * Creates a new workspace in the current organization.
 */
export const postWorkspacesMutation = (options?: Partial<Options<PostWorkspacesData>>): UseMutationOptions<PostWorkspacesResponse, PostWorkspacesError, Options<PostWorkspacesData>> => {
    const mutationOptions: UseMutationOptions<PostWorkspacesResponse, PostWorkspacesError, Options<PostWorkspacesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postWorkspaces({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete workspace
 * Deletes a workspace by its unique identifier.
 */
export const deleteWorkspacesByWorkspaceIdMutation = (options?: Partial<Options<DeleteWorkspacesByWorkspaceIdData>>): UseMutationOptions<DeleteWorkspacesByWorkspaceIdResponse, DeleteWorkspacesByWorkspaceIdError, Options<DeleteWorkspacesByWorkspaceIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteWorkspacesByWorkspaceIdResponse, DeleteWorkspacesByWorkspaceIdError, Options<DeleteWorkspacesByWorkspaceIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteWorkspacesByWorkspaceId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesByWorkspaceIdQueryKey = (options: Options<GetWorkspacesByWorkspaceIdData>) => createQueryKey('getWorkspacesByWorkspaceId', options);

/**
 * Get workspace by ID
 * Retrieves a specific workspace by its unique identifier.
 */
export const getWorkspacesByWorkspaceIdOptions = (options: Options<GetWorkspacesByWorkspaceIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdQueryKey(options)
    });
};

/**
 * Update workspace
 * Updates an existing workspace by its unique identifier.
 */
export const putWorkspacesByWorkspaceIdMutation = (options?: Partial<Options<PutWorkspacesByWorkspaceIdData>>): UseMutationOptions<PutWorkspacesByWorkspaceIdResponse, PutWorkspacesByWorkspaceIdError, Options<PutWorkspacesByWorkspaceIdData>> => {
    const mutationOptions: UseMutationOptions<PutWorkspacesByWorkspaceIdResponse, PutWorkspacesByWorkspaceIdError, Options<PutWorkspacesByWorkspaceIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putWorkspacesByWorkspaceId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove role from workspace member
 * Removes a role from a user in a specific workspace.
 */
export const deleteWorkspacesByWorkspaceIdMembersByUserIdRoleMutation = (options?: Partial<Options<DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleData>>): UseMutationOptions<DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleError, Options<DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleData>> => {
    const mutationOptions: UseMutationOptions<DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleError, Options<DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteWorkspacesByWorkspaceIdMembersByUserIdRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesByWorkspaceIdMembersByUserIdRoleQueryKey = (options: Options<GetWorkspacesByWorkspaceIdMembersByUserIdRoleData>) => createQueryKey('getWorkspacesByWorkspaceIdMembersByUserIdRole', options);

/**
 * Get user roles in workspace
 * Retrieves the roles assigned to a specific user in a workspace.
 */
export const getWorkspacesByWorkspaceIdMembersByUserIdRoleOptions = (options: Options<GetWorkspacesByWorkspaceIdMembersByUserIdRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdMembersByUserIdRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdMembersByUserIdRoleQueryKey(options)
    });
};

export const postWorkspacesByWorkspaceIdMembersByUserIdRoleQueryKey = (options: Options<PostWorkspacesByWorkspaceIdMembersByUserIdRoleData>) => createQueryKey('postWorkspacesByWorkspaceIdMembersByUserIdRole', options);

/**
 * Add role to workspace member
 * Assigns a role to a user in a specific workspace.
 */
export const postWorkspacesByWorkspaceIdMembersByUserIdRoleOptions = (options: Options<PostWorkspacesByWorkspaceIdMembersByUserIdRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postWorkspacesByWorkspaceIdMembersByUserIdRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postWorkspacesByWorkspaceIdMembersByUserIdRoleQueryKey(options)
    });
};

/**
 * Add role to workspace member
 * Assigns a role to a user in a specific workspace.
 */
export const postWorkspacesByWorkspaceIdMembersByUserIdRoleMutation = (options?: Partial<Options<PostWorkspacesByWorkspaceIdMembersByUserIdRoleData>>): UseMutationOptions<PostWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, PostWorkspacesByWorkspaceIdMembersByUserIdRoleError, Options<PostWorkspacesByWorkspaceIdMembersByUserIdRoleData>> => {
    const mutationOptions: UseMutationOptions<PostWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, PostWorkspacesByWorkspaceIdMembersByUserIdRoleError, Options<PostWorkspacesByWorkspaceIdMembersByUserIdRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postWorkspacesByWorkspaceIdMembersByUserIdRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesByWorkspaceIdMembersQueryKey = (options: Options<GetWorkspacesByWorkspaceIdMembersData>) => createQueryKey('getWorkspacesByWorkspaceIdMembers', options);

/**
 * List workspace members
 * Retrieves all members in a specific workspace.
 */
export const getWorkspacesByWorkspaceIdMembersOptions = (options: Options<GetWorkspacesByWorkspaceIdMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdMembersQueryKey(options)
    });
};

export const getRolesQueryKey = (options?: Options<GetRolesData>) => createQueryKey('getRoles', options);

/**
 * List all roles
 * Retrieves all system roles with their associated permission scopes.
 */
export const getRolesOptions = (options?: Options<GetRolesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRoles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRolesQueryKey(options)
    });
};

export const getPlansQueryKey = (options?: Options<GetPlansData>) => createQueryKey('getPlans', options);

/**
 * List available plans
 * Retrieves all available plans. If authenticated, the current plan will be marked.
 */
export const getPlansOptions = (options?: Options<GetPlansData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPlans({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPlansQueryKey(options)
    });
};

export const getPlansCurrentQueryKey = (options?: Options<GetPlansCurrentData>) => createQueryKey('getPlansCurrent', options);

/**
 * Get current plan
 * Retrieves the current plan for the authenticated organization with usage details.
 */
export const getPlansCurrentOptions = (options?: Options<GetPlansCurrentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPlansCurrent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPlansCurrentQueryKey(options)
    });
};

export const getSettingsQueryKey = (options?: Options<GetSettingsData>) => createQueryKey('getSettings', options);

/**
 * Get all organization settings
 * Retrieves all settings (custom and service) for the organization.
 */
export const getSettingsOptions = (options?: Options<GetSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsQueryKey(options)
    });
};

export const getSettingsCustomQueryKey = (options?: Options<GetSettingsCustomData>) => createQueryKey('getSettingsCustom', options);

/**
 * Get all custom settings
 * Retrieves all custom settings for the organization.
 */
export const getSettingsCustomOptions = (options?: Options<GetSettingsCustomData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsCustom({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsCustomQueryKey(options)
    });
};

export const postSettingsCustomQueryKey = (options?: Options<PostSettingsCustomData>) => createQueryKey('postSettingsCustom', options);

/**
 * Create custom setting
 * Creates a new custom setting for the organization.
 */
export const postSettingsCustomOptions = (options?: Options<PostSettingsCustomData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postSettingsCustom({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postSettingsCustomQueryKey(options)
    });
};

/**
 * Create custom setting
 * Creates a new custom setting for the organization.
 */
export const postSettingsCustomMutation = (options?: Partial<Options<PostSettingsCustomData>>): UseMutationOptions<PostSettingsCustomResponse, PostSettingsCustomError, Options<PostSettingsCustomData>> => {
    const mutationOptions: UseMutationOptions<PostSettingsCustomResponse, PostSettingsCustomError, Options<PostSettingsCustomData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postSettingsCustom({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete custom setting
 * Deletes a custom setting by its slug.
 */
export const deleteSettingsCustomBySettingSlugMutation = (options?: Partial<Options<DeleteSettingsCustomBySettingSlugData>>): UseMutationOptions<DeleteSettingsCustomBySettingSlugResponse, DeleteSettingsCustomBySettingSlugError, Options<DeleteSettingsCustomBySettingSlugData>> => {
    const mutationOptions: UseMutationOptions<DeleteSettingsCustomBySettingSlugResponse, DeleteSettingsCustomBySettingSlugError, Options<DeleteSettingsCustomBySettingSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSettingsCustomBySettingSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSettingsCustomBySettingSlugQueryKey = (options: Options<GetSettingsCustomBySettingSlugData>) => createQueryKey('getSettingsCustomBySettingSlug', options);

/**
 * Get custom setting by slug
 * Retrieves a specific custom setting by its slug.
 */
export const getSettingsCustomBySettingSlugOptions = (options: Options<GetSettingsCustomBySettingSlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsCustomBySettingSlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsCustomBySettingSlugQueryKey(options)
    });
};

/**
 * Update custom setting
 * Updates an existing custom setting by its slug.
 */
export const putSettingsCustomBySettingSlugMutation = (options?: Partial<Options<PutSettingsCustomBySettingSlugData>>): UseMutationOptions<PutSettingsCustomBySettingSlugResponse, PutSettingsCustomBySettingSlugError, Options<PutSettingsCustomBySettingSlugData>> => {
    const mutationOptions: UseMutationOptions<PutSettingsCustomBySettingSlugResponse, PutSettingsCustomBySettingSlugError, Options<PutSettingsCustomBySettingSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putSettingsCustomBySettingSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSettingsCustomBySettingSlugValueQueryKey = (options: Options<GetSettingsCustomBySettingSlugValueData>) => createQueryKey('getSettingsCustomBySettingSlugValue', options);

/**
 * Get custom setting value
 * Retrieves only the value of a specific custom setting by its slug.
 */
export const getSettingsCustomBySettingSlugValueOptions = (options: Options<GetSettingsCustomBySettingSlugValueData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsCustomBySettingSlugValue({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsCustomBySettingSlugValueQueryKey(options)
    });
};

export const getSettingsServiceQueryKey = (options?: Options<GetSettingsServiceData>) => createQueryKey('getSettingsService', options);

/**
 * Get all service settings
 * Retrieves all service settings for the organization.
 */
export const getSettingsServiceOptions = (options?: Options<GetSettingsServiceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsService({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsServiceQueryKey(options)
    });
};

export const getSettingsServiceBySettingSlugQueryKey = (options: Options<GetSettingsServiceBySettingSlugData>) => createQueryKey('getSettingsServiceBySettingSlug', options);

/**
 * Get service setting by slug
 * Retrieves a specific service setting by its slug.
 */
export const getSettingsServiceBySettingSlugOptions = (options: Options<GetSettingsServiceBySettingSlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsServiceBySettingSlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsServiceBySettingSlugQueryKey(options)
    });
};

/**
 * Upsert service setting
 * Updates an existing service setting or creates it if it does not exist.
 */
export const putSettingsServiceBySettingSlugMutation = (options?: Partial<Options<PutSettingsServiceBySettingSlugData>>): UseMutationOptions<PutSettingsServiceBySettingSlugResponse, PutSettingsServiceBySettingSlugError, Options<PutSettingsServiceBySettingSlugData>> => {
    const mutationOptions: UseMutationOptions<PutSettingsServiceBySettingSlugResponse, PutSettingsServiceBySettingSlugError, Options<PutSettingsServiceBySettingSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putSettingsServiceBySettingSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSettingsServiceBySettingSlugValueQueryKey = (options: Options<GetSettingsServiceBySettingSlugValueData>) => createQueryKey('getSettingsServiceBySettingSlugValue', options);

/**
 * Get service setting value
 * Retrieves only the value of a specific service setting by its slug.
 */
export const getSettingsServiceBySettingSlugValueOptions = (options: Options<GetSettingsServiceBySettingSlugValueData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsServiceBySettingSlugValue({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsServiceBySettingSlugValueQueryKey(options)
    });
};

export const getWorkspacesByWorkspaceIdSettingsQueryKey = (options: Options<GetWorkspacesByWorkspaceIdSettingsData>) => createQueryKey('getWorkspacesByWorkspaceIdSettings', options);

/**
 * Get all workspace settings
 * Retrieves all settings (custom and service) for the workspace.
 */
export const getWorkspacesByWorkspaceIdSettingsOptions = (options: Options<GetWorkspacesByWorkspaceIdSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdSettingsQueryKey(options)
    });
};

export const getWorkspacesByWorkspaceIdSettingsCustomQueryKey = (options: Options<GetWorkspacesByWorkspaceIdSettingsCustomData>) => createQueryKey('getWorkspacesByWorkspaceIdSettingsCustom', options);

/**
 * Get all workspace custom settings
 * Retrieves all custom settings for the workspace.
 */
export const getWorkspacesByWorkspaceIdSettingsCustomOptions = (options: Options<GetWorkspacesByWorkspaceIdSettingsCustomData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdSettingsCustom({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdSettingsCustomQueryKey(options)
    });
};

export const postWorkspacesByWorkspaceIdSettingsCustomQueryKey = (options: Options<PostWorkspacesByWorkspaceIdSettingsCustomData>) => createQueryKey('postWorkspacesByWorkspaceIdSettingsCustom', options);

/**
 * Create workspace custom setting
 * Creates a new custom setting for the workspace.
 */
export const postWorkspacesByWorkspaceIdSettingsCustomOptions = (options: Options<PostWorkspacesByWorkspaceIdSettingsCustomData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postWorkspacesByWorkspaceIdSettingsCustom({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postWorkspacesByWorkspaceIdSettingsCustomQueryKey(options)
    });
};

/**
 * Create workspace custom setting
 * Creates a new custom setting for the workspace.
 */
export const postWorkspacesByWorkspaceIdSettingsCustomMutation = (options?: Partial<Options<PostWorkspacesByWorkspaceIdSettingsCustomData>>): UseMutationOptions<PostWorkspacesByWorkspaceIdSettingsCustomResponse, PostWorkspacesByWorkspaceIdSettingsCustomError, Options<PostWorkspacesByWorkspaceIdSettingsCustomData>> => {
    const mutationOptions: UseMutationOptions<PostWorkspacesByWorkspaceIdSettingsCustomResponse, PostWorkspacesByWorkspaceIdSettingsCustomError, Options<PostWorkspacesByWorkspaceIdSettingsCustomData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postWorkspacesByWorkspaceIdSettingsCustom({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete workspace custom setting
 * Deletes a workspace custom setting by its slug.
 */
export const deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugMutation = (options?: Partial<Options<DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>>): UseMutationOptions<DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugError, Options<DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>> => {
    const mutationOptions: UseMutationOptions<DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugError, Options<DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugQueryKey = (options: Options<GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>) => createQueryKey('getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug', options);

/**
 * Get workspace custom setting by slug
 * Retrieves a specific workspace custom setting by its slug.
 */
export const getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugOptions = (options: Options<GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugQueryKey(options)
    });
};

/**
 * Update workspace custom setting
 * Updates an existing workspace custom setting by its slug.
 */
export const putWorkspacesByWorkspaceIdSettingsCustomBySettingSlugMutation = (options?: Partial<Options<PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>>): UseMutationOptions<PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugError, Options<PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>> => {
    const mutationOptions: UseMutationOptions<PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugError, Options<PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putWorkspacesByWorkspaceIdSettingsCustomBySettingSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueQueryKey = (options: Options<GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueData>) => createQueryKey('getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue', options);

/**
 * Get workspace custom setting value
 * Retrieves only the value of a specific workspace custom setting by its slug.
 */
export const getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueOptions = (options: Options<GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueQueryKey(options)
    });
};

export const getWorkspacesByWorkspaceIdSettingsServiceQueryKey = (options: Options<GetWorkspacesByWorkspaceIdSettingsServiceData>) => createQueryKey('getWorkspacesByWorkspaceIdSettingsService', options);

/**
 * Get all workspace service settings
 * Retrieves all service settings for the workspace.
 */
export const getWorkspacesByWorkspaceIdSettingsServiceOptions = (options: Options<GetWorkspacesByWorkspaceIdSettingsServiceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdSettingsService({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdSettingsServiceQueryKey(options)
    });
};

/**
 * Delete workspace service setting override
 * Deletes a workspace-level override for a service setting, reverting to organization defaults.
 */
export const deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugMutation = (options?: Partial<Options<DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>>): UseMutationOptions<DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugError, Options<DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>> => {
    const mutationOptions: UseMutationOptions<DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugError, Options<DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugQueryKey = (options: Options<GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>) => createQueryKey('getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug', options);

/**
 * Get workspace service setting by slug
 * Retrieves a specific workspace service setting by its slug.
 */
export const getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugOptions = (options: Options<GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugQueryKey(options)
    });
};

/**
 * Upsert workspace service setting
 * Updates an existing workspace service setting or creates it if it does not exist.
 */
export const putWorkspacesByWorkspaceIdSettingsServiceBySettingSlugMutation = (options?: Partial<Options<PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>>): UseMutationOptions<PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugError, Options<PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>> => {
    const mutationOptions: UseMutationOptions<PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugError, Options<PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putWorkspacesByWorkspaceIdSettingsServiceBySettingSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueQueryKey = (options: Options<GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueData>) => createQueryKey('getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue', options);

/**
 * Get workspace service setting value
 * Retrieves only the value of a specific workspace service setting by its slug.
 */
export const getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueOptions = (options: Options<GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueQueryKey(options)
    });
};

export const getCodesByCodeIdScansQueryKey = (options: Options<GetCodesByCodeIdScansData>) => createQueryKey('getCodesByCodeIdScans', options);

/**
 * List QR Code Scans
 * Retrieves a paginated list of scans for a specific QR Code with optional filtering
 */
export const getCodesByCodeIdScansOptions = (options: Options<GetCodesByCodeIdScansData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdScans({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdScansQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getCodesByCodeIdScansInfiniteQueryKey = (options: Options<GetCodesByCodeIdScansData>): QueryKey<Options<GetCodesByCodeIdScansData>> => createQueryKey('getCodesByCodeIdScans', options, true);

/**
 * List QR Code Scans
 * Retrieves a paginated list of scans for a specific QR Code with optional filtering
 */
export const getCodesByCodeIdScansInfiniteOptions = (options: Options<GetCodesByCodeIdScansData>) => {
    return infiniteQueryOptions<unknown, GetCodesByCodeIdScansError, InfiniteData<unknown>, QueryKey<Options<GetCodesByCodeIdScansData>>, number | Pick<QueryKey<Options<GetCodesByCodeIdScansData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCodesByCodeIdScansData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCodesByCodeIdScans({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdScansInfiniteQueryKey(options)
    });
};

export const getCodesByCodeIdRouterRulesQueryKey = (options: Options<GetCodesByCodeIdRouterRulesData>) => createQueryKey('getCodesByCodeIdRouterRules', options);

/**
 * List Router Rule Assignments
 * Retrieves all router rule assignments for a specific QR code with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data.
 */
export const getCodesByCodeIdRouterRulesOptions = (options: Options<GetCodesByCodeIdRouterRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdRouterRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdRouterRulesQueryKey(options)
    });
};

export const getCodesByCodeIdRouterRulesInfiniteQueryKey = (options: Options<GetCodesByCodeIdRouterRulesData>): QueryKey<Options<GetCodesByCodeIdRouterRulesData>> => createQueryKey('getCodesByCodeIdRouterRules', options, true);

/**
 * List Router Rule Assignments
 * Retrieves all router rule assignments for a specific QR code with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data.
 */
export const getCodesByCodeIdRouterRulesInfiniteOptions = (options: Options<GetCodesByCodeIdRouterRulesData>) => {
    return infiniteQueryOptions<GetCodesByCodeIdRouterRulesResponse, GetCodesByCodeIdRouterRulesError, InfiniteData<GetCodesByCodeIdRouterRulesResponse>, QueryKey<Options<GetCodesByCodeIdRouterRulesData>>, number | Pick<QueryKey<Options<GetCodesByCodeIdRouterRulesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCodesByCodeIdRouterRulesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCodesByCodeIdRouterRules({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdRouterRulesInfiniteQueryKey(options)
    });
};

export const postCodesByCodeIdRouterRulesQueryKey = (options: Options<PostCodesByCodeIdRouterRulesData>) => createQueryKey('postCodesByCodeIdRouterRules', options);

/**
 * Create Router Rule Assignment
 * Assigns a router rule to a QR code. You can reference an existing template by ID/name or create an inline custom rule. Rules with the same priority are evaluated in creation order. Scan limits and loop functionality are supported.
 */
export const postCodesByCodeIdRouterRulesOptions = (options: Options<PostCodesByCodeIdRouterRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesByCodeIdRouterRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesByCodeIdRouterRulesQueryKey(options)
    });
};

/**
 * Create Router Rule Assignment
 * Assigns a router rule to a QR code. You can reference an existing template by ID/name or create an inline custom rule. Rules with the same priority are evaluated in creation order. Scan limits and loop functionality are supported.
 */
export const postCodesByCodeIdRouterRulesMutation = (options?: Partial<Options<PostCodesByCodeIdRouterRulesData>>): UseMutationOptions<PostCodesByCodeIdRouterRulesResponse, PostCodesByCodeIdRouterRulesError, Options<PostCodesByCodeIdRouterRulesData>> => {
    const mutationOptions: UseMutationOptions<PostCodesByCodeIdRouterRulesResponse, PostCodesByCodeIdRouterRulesError, Options<PostCodesByCodeIdRouterRulesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesByCodeIdRouterRules({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Router Rule Assignment
 * Deletes a router rule assignment. Rules that have been used (totalScans > 0) cannot be deleted to preserve analytics data. Consider disabling the rule instead.
 */
export const deleteCodesByCodeIdRouterRulesByRouterRuleIdMutation = (options?: Partial<Options<DeleteCodesByCodeIdRouterRulesByRouterRuleIdData>>): UseMutationOptions<DeleteCodesByCodeIdRouterRulesByRouterRuleIdResponse, DeleteCodesByCodeIdRouterRulesByRouterRuleIdError, Options<DeleteCodesByCodeIdRouterRulesByRouterRuleIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdRouterRulesByRouterRuleIdResponse, DeleteCodesByCodeIdRouterRulesByRouterRuleIdError, Options<DeleteCodesByCodeIdRouterRulesByRouterRuleIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdRouterRulesByRouterRuleId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesByCodeIdRouterRulesByRouterRuleIdQueryKey = (options: Options<GetCodesByCodeIdRouterRulesByRouterRuleIdData>) => createQueryKey('getCodesByCodeIdRouterRulesByRouterRuleId', options);

/**
 * Get Router Rule Assignment
 * Retrieves a specific router rule assignment for a QR code. Returns the rule with enriched template data, usage statistics, and audit information.
 */
export const getCodesByCodeIdRouterRulesByRouterRuleIdOptions = (options: Options<GetCodesByCodeIdRouterRulesByRouterRuleIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdRouterRulesByRouterRuleId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdRouterRulesByRouterRuleIdQueryKey(options)
    });
};

/**
 * Update Router Rule Assignment
 * Updates a router rule assignment. You can change the rule source (template vs inline), priority, data configuration, and other settings. Validation is context-aware and will validate dynamicData against the existing or provided dataType. Priority conflicts are checked.
 */
export const putCodesByCodeIdRouterRulesByRouterRuleIdMutation = (options?: Partial<Options<PutCodesByCodeIdRouterRulesByRouterRuleIdData>>): UseMutationOptions<PutCodesByCodeIdRouterRulesByRouterRuleIdResponse, PutCodesByCodeIdRouterRulesByRouterRuleIdError, Options<PutCodesByCodeIdRouterRulesByRouterRuleIdData>> => {
    const mutationOptions: UseMutationOptions<PutCodesByCodeIdRouterRulesByRouterRuleIdResponse, PutCodesByCodeIdRouterRulesByRouterRuleIdError, Options<PutCodesByCodeIdRouterRulesByRouterRuleIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putCodesByCodeIdRouterRulesByRouterRuleId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesDeletedQueryKey = (options?: Options<GetCodesDeletedData>) => createQueryKey('getCodesDeleted', options);

/**
 * List Soft Deleted QR Codes
 * Retrieves a paginated list of soft deleted QR Codes with optional filtering
 */
export const getCodesDeletedOptions = (options?: Options<GetCodesDeletedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesDeleted({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesDeletedQueryKey(options)
    });
};

export const getCodesDeletedInfiniteQueryKey = (options?: Options<GetCodesDeletedData>): QueryKey<Options<GetCodesDeletedData>> => createQueryKey('getCodesDeleted', options, true);

/**
 * List Soft Deleted QR Codes
 * Retrieves a paginated list of soft deleted QR Codes with optional filtering
 */
export const getCodesDeletedInfiniteOptions = (options?: Options<GetCodesDeletedData>) => {
    return infiniteQueryOptions<GetCodesDeletedResponse, GetCodesDeletedError, InfiniteData<GetCodesDeletedResponse>, QueryKey<Options<GetCodesDeletedData>>, number | Pick<QueryKey<Options<GetCodesDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCodesDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCodesDeleted({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesDeletedInfiniteQueryKey(options)
    });
};

export const getCodesLinksQueryKey = (options?: Options<GetCodesLinksData>) => createQueryKey('getCodesLinks', options);

/**
 * List QR Code Links
 * Retrieves a paginated list of all QR Code links with optional filtering
 */
export const getCodesLinksOptions = (options?: Options<GetCodesLinksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesLinks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesLinksQueryKey(options)
    });
};

export const getCodesLinksInfiniteQueryKey = (options?: Options<GetCodesLinksData>): QueryKey<Options<GetCodesLinksData>> => createQueryKey('getCodesLinks', options, true);

/**
 * List QR Code Links
 * Retrieves a paginated list of all QR Code links with optional filtering
 */
export const getCodesLinksInfiniteOptions = (options?: Options<GetCodesLinksData>) => {
    return infiniteQueryOptions<GetCodesLinksResponse, GetCodesLinksError, InfiniteData<GetCodesLinksResponse>, QueryKey<Options<GetCodesLinksData>>, number | Pick<QueryKey<Options<GetCodesLinksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCodesLinksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCodesLinks({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesLinksInfiniteQueryKey(options)
    });
};

/**
 * Soft Delete QR Code
 * Marks a QR Code as deleted without permanently removing it from the system. Usage limits are not affected and the code can potentially be restored.
 */
export const deleteCodesByCodeIdMutation = (options?: Partial<Options<DeleteCodesByCodeIdData>>): UseMutationOptions<DeleteCodesByCodeIdResponse, DeleteCodesByCodeIdError, Options<DeleteCodesByCodeIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdResponse, DeleteCodesByCodeIdError, Options<DeleteCodesByCodeIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesByCodeIdQueryKey = (options: Options<GetCodesByCodeIdData>) => createQueryKey('getCodesByCodeId', options);

/**
 * Get QR Code
 * Retrieves a QR Code by its unique identifier
 */
export const getCodesByCodeIdOptions = (options: Options<GetCodesByCodeIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdQueryKey(options)
    });
};

/**
 * Update QR Code
 * Updates an existing QR Code with new data and options. Supports changing dataType for dynamic codes (e.g., from URL to WiFi configuration). When changing dataType, ensure metadata structure matches the new dataType requirements. This operation creates a new version of the QR code.
 */
export const putCodesByCodeIdMutation = (options?: Partial<Options<PutCodesByCodeIdData>>): UseMutationOptions<PutCodesByCodeIdResponse, PutCodesByCodeIdError, Options<PutCodesByCodeIdData>> => {
    const mutationOptions: UseMutationOptions<PutCodesByCodeIdResponse, PutCodesByCodeIdError, Options<PutCodesByCodeIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putCodesByCodeId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Bulk Soft Delete QR Codes
 * Soft deletes multiple QR codes by their IDs. The codes are marked as deleted but not permanently removed from the system.
 */
export const deleteCodesMutation = (options?: Partial<Options<DeleteCodesData>>): UseMutationOptions<DeleteCodesResponse, DeleteCodesError, Options<DeleteCodesData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesResponse, DeleteCodesError, Options<DeleteCodesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodes({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesQueryKey = (options?: Options<GetCodesData>) => createQueryKey('getCodes', options);

/**
 * List QR Codes
 * Retrieves a paginated list of QR Codes with optional filtering
 */
export const getCodesOptions = (options?: Options<GetCodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesQueryKey(options)
    });
};

export const getCodesInfiniteQueryKey = (options?: Options<GetCodesData>): QueryKey<Options<GetCodesData>> => createQueryKey('getCodes', options, true);

/**
 * List QR Codes
 * Retrieves a paginated list of QR Codes with optional filtering
 */
export const getCodesInfiniteOptions = (options?: Options<GetCodesData>) => {
    return infiniteQueryOptions<GetCodesResponse, GetCodesError, InfiniteData<GetCodesResponse>, QueryKey<Options<GetCodesData>>, number | Pick<QueryKey<Options<GetCodesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCodesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCodes({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesInfiniteQueryKey(options)
    });
};

export const postCodesQueryKey = (options?: Options<PostCodesData>) => createQueryKey('postCodes', options);

/**
 * Create QR Code
 * Creates a new QR Code with the specified data and options. Supports different dataTypes for dynamic codes including WiFi configuration, contact cards (vCard), plain text, email composition, calendar events, file downloads, and custom JSON data. Each dataType has specific metadata requirements that determine how the QR code is processed when scanned.
 */
export const postCodesOptions = (options?: Options<PostCodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesQueryKey(options)
    });
};

/**
 * Create QR Code
 * Creates a new QR Code with the specified data and options. Supports different dataTypes for dynamic codes including WiFi configuration, contact cards (vCard), plain text, email composition, calendar events, file downloads, and custom JSON data. Each dataType has specific metadata requirements that determine how the QR code is processed when scanned.
 */
export const postCodesMutation = (options?: Partial<Options<PostCodesData>>): UseMutationOptions<PostCodesResponse, PostCodesError, Options<PostCodesData>> => {
    const mutationOptions: UseMutationOptions<PostCodesResponse, PostCodesError, Options<PostCodesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodes({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Partially update QR Code Options
 * Partially updates an existing QR Code's options using a deep merge. This will create a new version of the QR Code. Supports updating dataType for dynamic codes, which changes how the QR code content is processed when scanned (e.g., returning WiFi configuration instead of URL redirect).
 */
export const putCodesByCodeIdOptionsMutation = (options?: Partial<Options<PutCodesByCodeIdOptionsData>>): UseMutationOptions<PutCodesByCodeIdOptionsResponse, PutCodesByCodeIdOptionsError, Options<PutCodesByCodeIdOptionsData>> => {
    const mutationOptions: UseMutationOptions<PutCodesByCodeIdOptionsResponse, PutCodesByCodeIdOptionsError, Options<PutCodesByCodeIdOptionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putCodesByCodeIdOptions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Bulk Permanent Delete QR Codes
 * Permanently deletes multiple QR codes by their IDs. This operation is irreversible and will remove all associated data including versions, files, and scans.
 */
export const deleteCodesPermanentMutation = (options?: Partial<Options<DeleteCodesPermanentData>>): UseMutationOptions<DeleteCodesPermanentResponse, DeleteCodesPermanentError, Options<DeleteCodesPermanentData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesPermanentResponse, DeleteCodesPermanentError, Options<DeleteCodesPermanentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesPermanent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete QR Code
 * Deletes a QR Code by its unique identifier
 */
export const deleteCodesByCodeIdPermanentMutation = (options?: Partial<Options<DeleteCodesByCodeIdPermanentData>>): UseMutationOptions<DeleteCodesByCodeIdPermanentResponse, DeleteCodesByCodeIdPermanentError, Options<DeleteCodesByCodeIdPermanentData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdPermanentResponse, DeleteCodesByCodeIdPermanentError, Options<DeleteCodesByCodeIdPermanentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdPermanent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postCodesByCodeIdRestoreQueryKey = (options: Options<PostCodesByCodeIdRestoreData>) => createQueryKey('postCodesByCodeIdRestore', options);

/**
 * Restore QR Code
 * Restores a soft-deleted QR Code by setting its deleted status to false. The code becomes active again and accessible through regular endpoints.
 */
export const postCodesByCodeIdRestoreOptions = (options: Options<PostCodesByCodeIdRestoreData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesByCodeIdRestore({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesByCodeIdRestoreQueryKey(options)
    });
};

/**
 * Restore QR Code
 * Restores a soft-deleted QR Code by setting its deleted status to false. The code becomes active again and accessible through regular endpoints.
 */
export const postCodesByCodeIdRestoreMutation = (options?: Partial<Options<PostCodesByCodeIdRestoreData>>): UseMutationOptions<PostCodesByCodeIdRestoreResponse, PostCodesByCodeIdRestoreError, Options<PostCodesByCodeIdRestoreData>> => {
    const mutationOptions: UseMutationOptions<PostCodesByCodeIdRestoreResponse, PostCodesByCodeIdRestoreError, Options<PostCodesByCodeIdRestoreData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesByCodeIdRestore({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postCodesBulkGetQueryKey = (options?: Options<PostCodesBulkGetData>) => createQueryKey('postCodesBulkGet', options);

/**
 * Bulk Get QR Codes by ID List
 * Retrieves multiple QR codes by their IDs in a single request with access control and detailed error reporting.
 */
export const postCodesBulkGetOptions = (options?: Options<PostCodesBulkGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesBulkGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesBulkGetQueryKey(options)
    });
};

/**
 * Bulk Get QR Codes by ID List
 * Retrieves multiple QR codes by their IDs in a single request with access control and detailed error reporting.
 */
export const postCodesBulkGetMutation = (options?: Partial<Options<PostCodesBulkGetData>>): UseMutationOptions<PostCodesBulkGetResponse, PostCodesBulkGetError, Options<PostCodesBulkGetData>> => {
    const mutationOptions: UseMutationOptions<PostCodesBulkGetResponse, PostCodesBulkGetError, Options<PostCodesBulkGetData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesBulkGet({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postCodesGenerateByTypeQueryKey = (options: Options<PostCodesGenerateByTypeData>) => createQueryKey('postCodesGenerateByType', options);

/**
 * Generate QR Code File Content
 * Generates a file content for a QR Code
 */
export const postCodesGenerateByTypeOptions = (options: Options<PostCodesGenerateByTypeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesGenerateByType({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesGenerateByTypeQueryKey(options)
    });
};

/**
 * Generate QR Code File Content
 * Generates a file content for a QR Code
 */
export const postCodesGenerateByTypeMutation = (options?: Partial<Options<PostCodesGenerateByTypeData>>): UseMutationOptions<PostCodesGenerateByTypeResponse, PostCodesGenerateByTypeError, Options<PostCodesGenerateByTypeData>> => {
    const mutationOptions: UseMutationOptions<PostCodesGenerateByTypeResponse, PostCodesGenerateByTypeError, Options<PostCodesGenerateByTypeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesGenerateByType({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postCodesValidateQueryKey = (options?: Options<PostCodesValidateData>) => createQueryKey('postCodesValidate', options);

/**
 * Validate QR Code Options
 * Validates QR Code styling options without generating or saving the QR Code
 */
export const postCodesValidateOptions = (options?: Options<PostCodesValidateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesValidate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesValidateQueryKey(options)
    });
};

/**
 * Validate QR Code Options
 * Validates QR Code styling options without generating or saving the QR Code
 */
export const postCodesValidateMutation = (options?: Partial<Options<PostCodesValidateData>>): UseMutationOptions<PostCodesValidateResponse, PostCodesValidateError, Options<PostCodesValidateData>> => {
    const mutationOptions: UseMutationOptions<PostCodesValidateResponse, PostCodesValidateError, Options<PostCodesValidateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesValidate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postCodesByCodeIdValidateQueryKey = (options: Options<PostCodesByCodeIdValidateData>) => createQueryKey('postCodesByCodeIdValidate', options);

/**
 * Validate Existing QR Code
 * Validates an existing QR Code and updates its validation status in the database
 */
export const postCodesByCodeIdValidateOptions = (options: Options<PostCodesByCodeIdValidateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesByCodeIdValidate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesByCodeIdValidateQueryKey(options)
    });
};

/**
 * Validate Existing QR Code
 * Validates an existing QR Code and updates its validation status in the database
 */
export const postCodesByCodeIdValidateMutation = (options?: Partial<Options<PostCodesByCodeIdValidateData>>): UseMutationOptions<PostCodesByCodeIdValidateResponse, PostCodesByCodeIdValidateError, Options<PostCodesByCodeIdValidateData>> => {
    const mutationOptions: UseMutationOptions<PostCodesByCodeIdValidateResponse, PostCodesByCodeIdValidateError, Options<PostCodesByCodeIdValidateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesByCodeIdValidate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postCodesLinksRefreshQueryKey = (options?: Options<PostCodesLinksRefreshData>) => createQueryKey('postCodesLinksRefresh', options);

/**
 * Bulk Refresh QR Code Links
 * Refreshes QR code links/files for all code versions matching the specified design element filters
 */
export const postCodesLinksRefreshOptions = (options?: Options<PostCodesLinksRefreshData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesLinksRefresh({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesLinksRefreshQueryKey(options)
    });
};

/**
 * Bulk Refresh QR Code Links
 * Refreshes QR code links/files for all code versions matching the specified design element filters
 */
export const postCodesLinksRefreshMutation = (options?: Partial<Options<PostCodesLinksRefreshData>>): UseMutationOptions<PostCodesLinksRefreshResponse, PostCodesLinksRefreshError, Options<PostCodesLinksRefreshData>> => {
    const mutationOptions: UseMutationOptions<PostCodesLinksRefreshResponse, PostCodesLinksRefreshError, Options<PostCodesLinksRefreshData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesLinksRefresh({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesByCodeIdVersionByVersionQueryKey = (options: Options<GetCodesByCodeIdVersionByVersionData>) => createQueryKey('getCodesByCodeIdVersionByVersion', options);

/**
 * Get QR Code version
 * Retrieves a specific version of a QR Code by ID and version number
 */
export const getCodesByCodeIdVersionByVersionOptions = (options: Options<GetCodesByCodeIdVersionByVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdVersionByVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdVersionByVersionQueryKey(options)
    });
};

/**
 * Delete All QR Code Versions
 * Deletes all versions of a QR Code except the current one
 */
export const deleteCodesByCodeIdVersionsMutation = (options?: Partial<Options<DeleteCodesByCodeIdVersionsData>>): UseMutationOptions<DeleteCodesByCodeIdVersionsResponse, DeleteCodesByCodeIdVersionsError, Options<DeleteCodesByCodeIdVersionsData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdVersionsResponse, DeleteCodesByCodeIdVersionsError, Options<DeleteCodesByCodeIdVersionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdVersions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesByCodeIdVersionsQueryKey = (options: Options<GetCodesByCodeIdVersionsData>) => createQueryKey('getCodesByCodeIdVersions', options);

/**
 * List QR Code versions
 * Retrieves all versions of a QR Code by its unique identifier
 */
export const getCodesByCodeIdVersionsOptions = (options: Options<GetCodesByCodeIdVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdVersionsQueryKey(options)
    });
};

export const postCodesByCodeIdVersionByVersionRestoreQueryKey = (options: Options<PostCodesByCodeIdVersionByVersionRestoreData>) => createQueryKey('postCodesByCodeIdVersionByVersionRestore', options);

/**
 * Restore QR Code Version
 * Restores a specific version of a QR Code as the current version
 */
export const postCodesByCodeIdVersionByVersionRestoreOptions = (options: Options<PostCodesByCodeIdVersionByVersionRestoreData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCodesByCodeIdVersionByVersionRestore({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCodesByCodeIdVersionByVersionRestoreQueryKey(options)
    });
};

/**
 * Restore QR Code Version
 * Restores a specific version of a QR Code as the current version
 */
export const postCodesByCodeIdVersionByVersionRestoreMutation = (options?: Partial<Options<PostCodesByCodeIdVersionByVersionRestoreData>>): UseMutationOptions<PostCodesByCodeIdVersionByVersionRestoreResponse, PostCodesByCodeIdVersionByVersionRestoreError, Options<PostCodesByCodeIdVersionByVersionRestoreData>> => {
    const mutationOptions: UseMutationOptions<PostCodesByCodeIdVersionByVersionRestoreResponse, PostCodesByCodeIdVersionByVersionRestoreError, Options<PostCodesByCodeIdVersionByVersionRestoreData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCodesByCodeIdVersionByVersionRestore({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesByCodeIdVersionByVersionByTypeQueryKey = (options: Options<GetCodesByCodeIdVersionByVersionByTypeData>) => createQueryKey('getCodesByCodeIdVersionByVersionByType', options);

/**
 * Get QR Code Version File Content
 * Retrieves the file content of a specific QR Code version
 */
export const getCodesByCodeIdVersionByVersionByTypeOptions = (options: Options<GetCodesByCodeIdVersionByVersionByTypeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdVersionByVersionByType({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdVersionByVersionByTypeQueryKey(options)
    });
};

export const getCodesByCodeIdVersionByVersionByTypeLinkQueryKey = (options: Options<GetCodesByCodeIdVersionByVersionByTypeLinkData>) => createQueryKey('getCodesByCodeIdVersionByVersionByTypeLink', options);

/**
 * Get QR Code Version Link
 * Retrieves a link to the file representation of a specific QR Code version
 */
export const getCodesByCodeIdVersionByVersionByTypeLinkOptions = (options: Options<GetCodesByCodeIdVersionByVersionByTypeLinkData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdVersionByVersionByTypeLink({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdVersionByVersionByTypeLinkQueryKey(options)
    });
};

/**
 * Delete QR Code version links
 * Deletes all QR Code version links for a specific version of a QR Code
 */
export const deleteCodesByCodeIdVersionsByVersionLinksMutation = (options?: Partial<Options<DeleteCodesByCodeIdVersionsByVersionLinksData>>): UseMutationOptions<DeleteCodesByCodeIdVersionsByVersionLinksResponse, DeleteCodesByCodeIdVersionsByVersionLinksError, Options<DeleteCodesByCodeIdVersionsByVersionLinksData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdVersionsByVersionLinksResponse, DeleteCodesByCodeIdVersionsByVersionLinksError, Options<DeleteCodesByCodeIdVersionsByVersionLinksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdVersionsByVersionLinks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete QR Code version link by Type
 * Deletes a specific QR Code version link for a specific version of a QR Code
 */
export const deleteCodesByCodeIdVersionsByVersionLinksByTypeMutation = (options?: Partial<Options<DeleteCodesByCodeIdVersionsByVersionLinksByTypeData>>): UseMutationOptions<DeleteCodesByCodeIdVersionsByVersionLinksByTypeResponse, DeleteCodesByCodeIdVersionsByVersionLinksByTypeError, Options<DeleteCodesByCodeIdVersionsByVersionLinksByTypeData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdVersionsByVersionLinksByTypeResponse, DeleteCodesByCodeIdVersionsByVersionLinksByTypeError, Options<DeleteCodesByCodeIdVersionsByVersionLinksByTypeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdVersionsByVersionLinksByType({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete All QR Code Versions Links
 * Deletes all file links for all versions of a QR Code
 */
export const deleteCodesByCodeIdVersionsLinksMutation = (options?: Partial<Options<DeleteCodesByCodeIdVersionsLinksData>>): UseMutationOptions<DeleteCodesByCodeIdVersionsLinksResponse, DeleteCodesByCodeIdVersionsLinksError, Options<DeleteCodesByCodeIdVersionsLinksData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdVersionsLinksResponse, DeleteCodesByCodeIdVersionsLinksError, Options<DeleteCodesByCodeIdVersionsLinksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdVersionsLinks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete All QR Code Versions Links by Type
 * Deletes a specific file type link for all versions of a QR Code
 */
export const deleteCodesByCodeIdVersionsLinksByTypeMutation = (options?: Partial<Options<DeleteCodesByCodeIdVersionsLinksByTypeData>>): UseMutationOptions<DeleteCodesByCodeIdVersionsLinksByTypeResponse, DeleteCodesByCodeIdVersionsLinksByTypeError, Options<DeleteCodesByCodeIdVersionsLinksByTypeData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdVersionsLinksByTypeResponse, DeleteCodesByCodeIdVersionsLinksByTypeError, Options<DeleteCodesByCodeIdVersionsLinksByTypeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdVersionsLinksByType({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCodesByCodeIdByTypeQueryKey = (options: Options<GetCodesByCodeIdByTypeData>) => createQueryKey('getCodesByCodeIdByType', options);

/**
 * Get QR Code File Content (SVG, PNG, PDF)
 * Retrieves the SVG, PNG, or PDF representation of a QR Code
 */
export const getCodesByCodeIdByTypeOptions = (options: Options<GetCodesByCodeIdByTypeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdByType({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdByTypeQueryKey(options)
    });
};

export const getCodesByCodeIdByTypeLinkQueryKey = (options: Options<GetCodesByCodeIdByTypeLinkData>) => createQueryKey('getCodesByCodeIdByTypeLink', options);

/**
 * Get QR Code link
 * Retrieves a link to the SVG, PNG, or PDF representation of a QR Code
 */
export const getCodesByCodeIdByTypeLinkOptions = (options: Options<GetCodesByCodeIdByTypeLinkData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCodesByCodeIdByTypeLink({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCodesByCodeIdByTypeLinkQueryKey(options)
    });
};

/**
 * Delete QR Code links
 * Deletes all links for the current version of a QR Code
 */
export const deleteCodesByCodeIdLinksMutation = (options?: Partial<Options<DeleteCodesByCodeIdLinksData>>): UseMutationOptions<DeleteCodesByCodeIdLinksResponse, DeleteCodesByCodeIdLinksError, Options<DeleteCodesByCodeIdLinksData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdLinksResponse, DeleteCodesByCodeIdLinksError, Options<DeleteCodesByCodeIdLinksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdLinks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete QR Code link by Type
 * Deletes a specific file type link for the current version of a QR Code
 */
export const deleteCodesByCodeIdLinksByTypeMutation = (options?: Partial<Options<DeleteCodesByCodeIdLinksByTypeData>>): UseMutationOptions<DeleteCodesByCodeIdLinksByTypeResponse, DeleteCodesByCodeIdLinksByTypeError, Options<DeleteCodesByCodeIdLinksByTypeData>> => {
    const mutationOptions: UseMutationOptions<DeleteCodesByCodeIdLinksByTypeResponse, DeleteCodesByCodeIdLinksByTypeError, Options<DeleteCodesByCodeIdLinksByTypeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCodesByCodeIdLinksByType({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTemplatesQueryKey = (options?: Options<GetTemplatesData>) => createQueryKey('getTemplates', options);

/**
 * List all templates
 * Retrieves all templates available to the user, grouped by organization and workspace.
 */
export const getTemplatesOptions = (options?: Options<GetTemplatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTemplates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTemplatesQueryKey(options)
    });
};

export const postTemplatesQueryKey = (options?: Options<PostTemplatesData>) => createQueryKey('postTemplates', options);

/**
 * Create a new template
 * Creates a new QR code template for an organization or workspace.
 */
export const postTemplatesOptions = (options?: Options<PostTemplatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postTemplates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postTemplatesQueryKey(options)
    });
};

/**
 * Create a new template
 * Creates a new QR code template for an organization or workspace.
 */
export const postTemplatesMutation = (options?: Partial<Options<PostTemplatesData>>): UseMutationOptions<PostTemplatesResponse, PostTemplatesError, Options<PostTemplatesData>> => {
    const mutationOptions: UseMutationOptions<PostTemplatesResponse, PostTemplatesError, Options<PostTemplatesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postTemplates({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTemplatesBaseQueryKey = (options?: Options<GetTemplatesBaseData>) => createQueryKey('getTemplatesBase', options);

/**
 * List base templates
 * Retrieves all base templates from the QRCodeJs library with optional name filtering.
 */
export const getTemplatesBaseOptions = (options?: Options<GetTemplatesBaseData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTemplatesBase({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTemplatesBaseQueryKey(options)
    });
};

/**
 * Delete template by ID
 * Deletes a template by its unique identifier. Fails if the template is used by codes.
 */
export const deleteTemplatesByTemplateIdMutation = (options?: Partial<Options<DeleteTemplatesByTemplateIdData>>): UseMutationOptions<DeleteTemplatesByTemplateIdResponse, DeleteTemplatesByTemplateIdError, Options<DeleteTemplatesByTemplateIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteTemplatesByTemplateIdResponse, DeleteTemplatesByTemplateIdError, Options<DeleteTemplatesByTemplateIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTemplatesByTemplateId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTemplatesByTemplateIdQueryKey = (options: Options<GetTemplatesByTemplateIdData>) => createQueryKey('getTemplatesByTemplateId', options);

/**
 * Get template by ID
 * Retrieves a template by its unique identifier.
 */
export const getTemplatesByTemplateIdOptions = (options: Options<GetTemplatesByTemplateIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTemplatesByTemplateId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTemplatesByTemplateIdQueryKey(options)
    });
};

/**
 * Update template by ID
 * Updates a template by its unique identifier.
 */
export const putTemplatesByTemplateIdMutation = (options?: Partial<Options<PutTemplatesByTemplateIdData>>): UseMutationOptions<PutTemplatesByTemplateIdResponse, PutTemplatesByTemplateIdError, Options<PutTemplatesByTemplateIdData>> => {
    const mutationOptions: UseMutationOptions<PutTemplatesByTemplateIdResponse, PutTemplatesByTemplateIdError, Options<PutTemplatesByTemplateIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putTemplatesByTemplateId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Partially update template options by ID
 * Partially updates a template options by its unique identifier using a deep merge. Use null to delete a field.
 */
export const putTemplatesByTemplateIdOptionsMutation = (options?: Partial<Options<PutTemplatesByTemplateIdOptionsData>>): UseMutationOptions<PutTemplatesByTemplateIdOptionsResponse, PutTemplatesByTemplateIdOptionsError, Options<PutTemplatesByTemplateIdOptionsData>> => {
    const mutationOptions: UseMutationOptions<PutTemplatesByTemplateIdOptionsResponse, PutTemplatesByTemplateIdOptionsError, Options<PutTemplatesByTemplateIdOptionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putTemplatesByTemplateIdOptions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTemplatesWorkspaceByWorkspaceIdQueryKey = (options: Options<GetTemplatesWorkspaceByWorkspaceIdData>) => createQueryKey('getTemplatesWorkspaceByWorkspaceId', options);

/**
 * List templates for a workspace
 * Retrieves all templates for a specific workspace.
 */
export const getTemplatesWorkspaceByWorkspaceIdOptions = (options: Options<GetTemplatesWorkspaceByWorkspaceIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTemplatesWorkspaceByWorkspaceId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTemplatesWorkspaceByWorkspaceIdQueryKey(options)
    });
};

export const getStylesQueryKey = (options?: Options<GetStylesData>) => createQueryKey('getStyles', options);

/**
 * List all styles
 * Retrieves all styles available to the user.
 */
export const getStylesOptions = (options?: Options<GetStylesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStyles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStylesQueryKey(options)
    });
};

export const postStylesQueryKey = (options?: Options<PostStylesData>) => createQueryKey('postStyles', options);

/**
 * Create a new style
 * Creates a new style for an organization or workspace.
 */
export const postStylesOptions = (options?: Options<PostStylesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postStyles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postStylesQueryKey(options)
    });
};

/**
 * Create a new style
 * Creates a new style for an organization or workspace.
 */
export const postStylesMutation = (options?: Partial<Options<PostStylesData>>): UseMutationOptions<PostStylesResponse, PostStylesError, Options<PostStylesData>> => {
    const mutationOptions: UseMutationOptions<PostStylesResponse, PostStylesError, Options<PostStylesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postStyles({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStylesBaseQueryKey = (options?: Options<GetStylesBaseData>) => createQueryKey('getStylesBase', options);

/**
 * List base styles
 * Retrieves all base styles from the QRCodeJs library with optional name filtering.
 */
export const getStylesBaseOptions = (options?: Options<GetStylesBaseData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStylesBase({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStylesBaseQueryKey(options)
    });
};

/**
 * Delete style by ID
 * Deletes a style by its unique identifier. Fails if the style is used by codes.
 */
export const deleteStylesByStyleIdMutation = (options?: Partial<Options<DeleteStylesByStyleIdData>>): UseMutationOptions<DeleteStylesByStyleIdResponse, DeleteStylesByStyleIdError, Options<DeleteStylesByStyleIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteStylesByStyleIdResponse, DeleteStylesByStyleIdError, Options<DeleteStylesByStyleIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteStylesByStyleId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStylesByStyleIdQueryKey = (options: Options<GetStylesByStyleIdData>) => createQueryKey('getStylesByStyleId', options);

/**
 * Get style by ID
 * Retrieves a style by its unique identifier.
 */
export const getStylesByStyleIdOptions = (options: Options<GetStylesByStyleIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStylesByStyleId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStylesByStyleIdQueryKey(options)
    });
};

/**
 * Update style by ID
 * Updates a style by its unique identifier.
 */
export const putStylesByStyleIdMutation = (options?: Partial<Options<PutStylesByStyleIdData>>): UseMutationOptions<PutStylesByStyleIdResponse, PutStylesByStyleIdError, Options<PutStylesByStyleIdData>> => {
    const mutationOptions: UseMutationOptions<PutStylesByStyleIdResponse, PutStylesByStyleIdError, Options<PutStylesByStyleIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putStylesByStyleId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Partially update style options by ID
 * Partially updates a style options by its unique identifier using a deep merge. Use null to delete a field.
 */
export const putStylesByStyleIdOptionsMutation = (options?: Partial<Options<PutStylesByStyleIdOptionsData>>): UseMutationOptions<PutStylesByStyleIdOptionsResponse, PutStylesByStyleIdOptionsError, Options<PutStylesByStyleIdOptionsData>> => {
    const mutationOptions: UseMutationOptions<PutStylesByStyleIdOptionsResponse, PutStylesByStyleIdOptionsError, Options<PutStylesByStyleIdOptionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putStylesByStyleIdOptions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStylesWorkspaceByWorkspaceIdQueryKey = (options: Options<GetStylesWorkspaceByWorkspaceIdData>) => createQueryKey('getStylesWorkspaceByWorkspaceId', options);

/**
 * List styles for a workspace
 * Retrieves all styles for a specific workspace.
 */
export const getStylesWorkspaceByWorkspaceIdOptions = (options: Options<GetStylesWorkspaceByWorkspaceIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStylesWorkspaceByWorkspaceId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStylesWorkspaceByWorkspaceIdQueryKey(options)
    });
};

export const getTextsQueryKey = (options?: Options<GetTextsData>) => createQueryKey('getTexts', options);

/**
 * List all texts
 * Retrieves all texts available to the user.
 */
export const getTextsOptions = (options?: Options<GetTextsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTexts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTextsQueryKey(options)
    });
};

export const postTextsQueryKey = (options?: Options<PostTextsData>) => createQueryKey('postTexts', options);

/**
 * Create a new text
 * Creates a new text for an organization or workspace.
 */
export const postTextsOptions = (options?: Options<PostTextsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postTexts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postTextsQueryKey(options)
    });
};

/**
 * Create a new text
 * Creates a new text for an organization or workspace.
 */
export const postTextsMutation = (options?: Partial<Options<PostTextsData>>): UseMutationOptions<PostTextsResponse, PostTextsError, Options<PostTextsData>> => {
    const mutationOptions: UseMutationOptions<PostTextsResponse, PostTextsError, Options<PostTextsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postTexts({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTextsBaseQueryKey = (options?: Options<GetTextsBaseData>) => createQueryKey('getTextsBase', options);

/**
 * List base texts
 * Retrieves all base text templates from the QRCodeJs library with optional name filtering.
 */
export const getTextsBaseOptions = (options?: Options<GetTextsBaseData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTextsBase({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTextsBaseQueryKey(options)
    });
};

/**
 * Delete text by ID
 * Deletes a text by its unique identifier. Fails if the text is used by codes.
 */
export const deleteTextsByTextIdMutation = (options?: Partial<Options<DeleteTextsByTextIdData>>): UseMutationOptions<DeleteTextsByTextIdResponse, DeleteTextsByTextIdError, Options<DeleteTextsByTextIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteTextsByTextIdResponse, DeleteTextsByTextIdError, Options<DeleteTextsByTextIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTextsByTextId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTextsByTextIdQueryKey = (options: Options<GetTextsByTextIdData>) => createQueryKey('getTextsByTextId', options);

/**
 * Get text by ID
 * Retrieves a text by its unique identifier.
 */
export const getTextsByTextIdOptions = (options: Options<GetTextsByTextIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTextsByTextId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTextsByTextIdQueryKey(options)
    });
};

/**
 * Update text by ID
 * Updates a text by its unique identifier.
 */
export const putTextsByTextIdMutation = (options?: Partial<Options<PutTextsByTextIdData>>): UseMutationOptions<PutTextsByTextIdResponse, PutTextsByTextIdError, Options<PutTextsByTextIdData>> => {
    const mutationOptions: UseMutationOptions<PutTextsByTextIdResponse, PutTextsByTextIdError, Options<PutTextsByTextIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putTextsByTextId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Partially update text options by ID
 * Partially updates a text options by its unique identifier using a deep merge. Use null to delete a field.
 */
export const putTextsByTextIdOptionsMutation = (options?: Partial<Options<PutTextsByTextIdOptionsData>>): UseMutationOptions<PutTextsByTextIdOptionsResponse, PutTextsByTextIdOptionsError, Options<PutTextsByTextIdOptionsData>> => {
    const mutationOptions: UseMutationOptions<PutTextsByTextIdOptionsResponse, PutTextsByTextIdOptionsError, Options<PutTextsByTextIdOptionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putTextsByTextIdOptions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTextsWorkspaceByWorkspaceIdQueryKey = (options: Options<GetTextsWorkspaceByWorkspaceIdData>) => createQueryKey('getTextsWorkspaceByWorkspaceId', options);

/**
 * List texts for a workspace
 * Retrieves all texts for a specific workspace.
 */
export const getTextsWorkspaceByWorkspaceIdOptions = (options: Options<GetTextsWorkspaceByWorkspaceIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTextsWorkspaceByWorkspaceId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTextsWorkspaceByWorkspaceIdQueryKey(options)
    });
};

export const getBordersQueryKey = (options?: Options<GetBordersData>) => createQueryKey('getBorders', options);

/**
 * List all borders
 * Retrieves all borders available to the user.
 */
export const getBordersOptions = (options?: Options<GetBordersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBorders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBordersQueryKey(options)
    });
};

export const postBordersQueryKey = (options?: Options<PostBordersData>) => createQueryKey('postBorders', options);

/**
 * Create a new border
 * Creates a new border for an organization or workspace.
 */
export const postBordersOptions = (options?: Options<PostBordersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postBorders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postBordersQueryKey(options)
    });
};

/**
 * Create a new border
 * Creates a new border for an organization or workspace.
 */
export const postBordersMutation = (options?: Partial<Options<PostBordersData>>): UseMutationOptions<PostBordersResponse, PostBordersError, Options<PostBordersData>> => {
    const mutationOptions: UseMutationOptions<PostBordersResponse, PostBordersError, Options<PostBordersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postBorders({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBordersBaseQueryKey = (options?: Options<GetBordersBaseData>) => createQueryKey('getBordersBase', options);

/**
 * List base borders
 * Retrieves all base border templates from the QRCodeJs library with optional name filtering.
 */
export const getBordersBaseOptions = (options?: Options<GetBordersBaseData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBordersBase({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBordersBaseQueryKey(options)
    });
};

/**
 * Delete border by ID
 * Deletes a border by its unique identifier.
 */
export const deleteBordersByBorderIdMutation = (options?: Partial<Options<DeleteBordersByBorderIdData>>): UseMutationOptions<DeleteBordersByBorderIdResponse, DeleteBordersByBorderIdError, Options<DeleteBordersByBorderIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteBordersByBorderIdResponse, DeleteBordersByBorderIdError, Options<DeleteBordersByBorderIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteBordersByBorderId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBordersByBorderIdQueryKey = (options: Options<GetBordersByBorderIdData>) => createQueryKey('getBordersByBorderId', options);

/**
 * Get border by ID
 * Retrieves a border by its unique identifier.
 */
export const getBordersByBorderIdOptions = (options: Options<GetBordersByBorderIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBordersByBorderId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBordersByBorderIdQueryKey(options)
    });
};

/**
 * Update border by ID
 * Updates a border by its unique identifier.
 */
export const putBordersByBorderIdMutation = (options?: Partial<Options<PutBordersByBorderIdData>>): UseMutationOptions<PutBordersByBorderIdResponse, PutBordersByBorderIdError, Options<PutBordersByBorderIdData>> => {
    const mutationOptions: UseMutationOptions<PutBordersByBorderIdResponse, PutBordersByBorderIdError, Options<PutBordersByBorderIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putBordersByBorderId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Partially update border options by ID
 * Partially updates border options by its unique identifier using a deep merge. Use null to delete a field.
 */
export const putBordersByBorderIdOptionsMutation = (options?: Partial<Options<PutBordersByBorderIdOptionsData>>): UseMutationOptions<PutBordersByBorderIdOptionsResponse, PutBordersByBorderIdOptionsError, Options<PutBordersByBorderIdOptionsData>> => {
    const mutationOptions: UseMutationOptions<PutBordersByBorderIdOptionsResponse, PutBordersByBorderIdOptionsError, Options<PutBordersByBorderIdOptionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putBordersByBorderIdOptions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBordersWorkspaceByWorkspaceIdQueryKey = (options: Options<GetBordersWorkspaceByWorkspaceIdData>) => createQueryKey('getBordersWorkspaceByWorkspaceId', options);

/**
 * List borders for a workspace
 * Retrieves all borders for a specific workspace.
 */
export const getBordersWorkspaceByWorkspaceIdOptions = (options: Options<GetBordersWorkspaceByWorkspaceIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBordersWorkspaceByWorkspaceId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBordersWorkspaceByWorkspaceIdQueryKey(options)
    });
};

export const getCountryCodesQueryKey = (options?: Options<GetCountryCodesData>) => createQueryKey('getCountryCodes', options);

/**
 * List All Country Codes
 * Retrieves a list of all available country codes with their names and full names
 */
export const getCountryCodesOptions = (options?: Options<GetCountryCodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCountryCodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCountryCodesQueryKey(options)
    });
};

export const getRouterRuleTemplatesQueryKey = (options?: Options<GetRouterRuleTemplatesData>) => createQueryKey('getRouterRuleTemplates', options);

/**
 * List Router Rule Templates
 * Retrieves available router rule templates based on user access. Returns global templates (if includeGlobal=true), organization-level templates, and workspace-specific templates the user has access to.
 */
export const getRouterRuleTemplatesOptions = (options?: Options<GetRouterRuleTemplatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRouterRuleTemplates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRouterRuleTemplatesQueryKey(options)
    });
};

export const getRouterRuleTemplatesInfiniteQueryKey = (options?: Options<GetRouterRuleTemplatesData>): QueryKey<Options<GetRouterRuleTemplatesData>> => createQueryKey('getRouterRuleTemplates', options, true);

/**
 * List Router Rule Templates
 * Retrieves available router rule templates based on user access. Returns global templates (if includeGlobal=true), organization-level templates, and workspace-specific templates the user has access to.
 */
export const getRouterRuleTemplatesInfiniteOptions = (options?: Options<GetRouterRuleTemplatesData>) => {
    return infiniteQueryOptions<unknown, GetRouterRuleTemplatesError, InfiniteData<unknown>, QueryKey<Options<GetRouterRuleTemplatesData>>, number | Pick<QueryKey<Options<GetRouterRuleTemplatesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetRouterRuleTemplatesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getRouterRuleTemplates({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRouterRuleTemplatesInfiniteQueryKey(options)
    });
};

export const postRouterRuleTemplatesQueryKey = (options?: Options<PostRouterRuleTemplatesData>) => createQueryKey('postRouterRuleTemplates', options);

/**
 * Create Router Rule Template
 * Creates a new router rule template. The template can be organization-level (no workspaceId) or workspace-specific. Template names must be unique within the organization scope.
 */
export const postRouterRuleTemplatesOptions = (options?: Options<PostRouterRuleTemplatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postRouterRuleTemplates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postRouterRuleTemplatesQueryKey(options)
    });
};

/**
 * Create Router Rule Template
 * Creates a new router rule template. The template can be organization-level (no workspaceId) or workspace-specific. Template names must be unique within the organization scope.
 */
export const postRouterRuleTemplatesMutation = (options?: Partial<Options<PostRouterRuleTemplatesData>>): UseMutationOptions<unknown, PostRouterRuleTemplatesError, Options<PostRouterRuleTemplatesData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostRouterRuleTemplatesError, Options<PostRouterRuleTemplatesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postRouterRuleTemplates({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Router Rule Template
 * Deletes a router rule template. Templates that are currently being used by router rules cannot be deleted. Only organization templates can be deleted (not global templates).
 */
export const deleteRouterRuleTemplatesByRouterRuleTemplateIdMutation = (options?: Partial<Options<DeleteRouterRuleTemplatesByRouterRuleTemplateIdData>>): UseMutationOptions<DeleteRouterRuleTemplatesByRouterRuleTemplateIdResponse, DeleteRouterRuleTemplatesByRouterRuleTemplateIdError, Options<DeleteRouterRuleTemplatesByRouterRuleTemplateIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteRouterRuleTemplatesByRouterRuleTemplateIdResponse, DeleteRouterRuleTemplatesByRouterRuleTemplateIdError, Options<DeleteRouterRuleTemplatesByRouterRuleTemplateIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRouterRuleTemplatesByRouterRuleTemplateId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRouterRuleTemplatesByRouterRuleTemplateIdQueryKey = (options: Options<GetRouterRuleTemplatesByRouterRuleTemplateIdData>) => createQueryKey('getRouterRuleTemplatesByRouterRuleTemplateId', options);

/**
 * Get Router Rule Template
 * Retrieves a specific router rule template by ID. Returns global templates and organization templates the user has access to.
 */
export const getRouterRuleTemplatesByRouterRuleTemplateIdOptions = (options: Options<GetRouterRuleTemplatesByRouterRuleTemplateIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRouterRuleTemplatesByRouterRuleTemplateId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRouterRuleTemplatesByRouterRuleTemplateIdQueryKey(options)
    });
};

/**
 * Update Router Rule Template
 * Updates a router rule template. Only organization templates can be updated (not global templates). Users can only update templates within their organization.
 */
export const putRouterRuleTemplatesByRouterRuleTemplateIdMutation = (options?: Partial<Options<PutRouterRuleTemplatesByRouterRuleTemplateIdData>>): UseMutationOptions<unknown, PutRouterRuleTemplatesByRouterRuleTemplateIdError, Options<PutRouterRuleTemplatesByRouterRuleTemplateIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, PutRouterRuleTemplatesByRouterRuleTemplateIdError, Options<PutRouterRuleTemplatesByRouterRuleTemplateIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putRouterRuleTemplatesByRouterRuleTemplateId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRouterRulesQueryKey = (options?: Options<GetRouterRulesData>) => createQueryKey('getRouterRules', options);

/**
 * List Organization Router Rules
 * Retrieves all router rules across the organization. Users with organization-level access see all rules, while workspace-limited users see only rules from their permitted workspaces.
 */
export const getRouterRulesOptions = (options?: Options<GetRouterRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRouterRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRouterRulesQueryKey(options)
    });
};

export const getRouterRulesInfiniteQueryKey = (options?: Options<GetRouterRulesData>): QueryKey<Options<GetRouterRulesData>> => createQueryKey('getRouterRules', options, true);

/**
 * List Organization Router Rules
 * Retrieves all router rules across the organization. Users with organization-level access see all rules, while workspace-limited users see only rules from their permitted workspaces.
 */
export const getRouterRulesInfiniteOptions = (options?: Options<GetRouterRulesData>) => {
    return infiniteQueryOptions<GetRouterRulesResponse, GetRouterRulesError, InfiniteData<GetRouterRulesResponse>, QueryKey<Options<GetRouterRulesData>>, number | Pick<QueryKey<Options<GetRouterRulesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetRouterRulesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getRouterRules({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRouterRulesInfiniteQueryKey(options)
    });
};

export const getWorkspacesByWorkspaceIdRouterRulesQueryKey = (options: Options<GetWorkspacesByWorkspaceIdRouterRulesData>) => createQueryKey('getWorkspacesByWorkspaceIdRouterRules', options);

/**
 * List Workspace Router Rule Assignments
 * Retrieves all router rule assignments within a specific workspace with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data and QR code context.
 */
export const getWorkspacesByWorkspaceIdRouterRulesOptions = (options: Options<GetWorkspacesByWorkspaceIdRouterRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspacesByWorkspaceIdRouterRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdRouterRulesQueryKey(options)
    });
};

export const getWorkspacesByWorkspaceIdRouterRulesInfiniteQueryKey = (options: Options<GetWorkspacesByWorkspaceIdRouterRulesData>): QueryKey<Options<GetWorkspacesByWorkspaceIdRouterRulesData>> => createQueryKey('getWorkspacesByWorkspaceIdRouterRules', options, true);

/**
 * List Workspace Router Rule Assignments
 * Retrieves all router rule assignments within a specific workspace with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data and QR code context.
 */
export const getWorkspacesByWorkspaceIdRouterRulesInfiniteOptions = (options: Options<GetWorkspacesByWorkspaceIdRouterRulesData>) => {
    return infiniteQueryOptions<GetWorkspacesByWorkspaceIdRouterRulesResponse, GetWorkspacesByWorkspaceIdRouterRulesError, InfiniteData<GetWorkspacesByWorkspaceIdRouterRulesResponse>, QueryKey<Options<GetWorkspacesByWorkspaceIdRouterRulesData>>, number | Pick<QueryKey<Options<GetWorkspacesByWorkspaceIdRouterRulesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetWorkspacesByWorkspaceIdRouterRulesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getWorkspacesByWorkspaceIdRouterRules({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspacesByWorkspaceIdRouterRulesInfiniteQueryKey(options)
    });
};

export const postWorkspacesByWorkspaceIdRouterRuleTemplatesQueryKey = (options: Options<PostWorkspacesByWorkspaceIdRouterRuleTemplatesData>) => createQueryKey('postWorkspacesByWorkspaceIdRouterRuleTemplates', options);

/**
 * Create Workspace Router Rule Template
 * Creates a new router rule template scoped to the specified workspace. Template names must be unique within the organization scope. The workspaceId from the URL path will be used to scope the template.
 */
export const postWorkspacesByWorkspaceIdRouterRuleTemplatesOptions = (options: Options<PostWorkspacesByWorkspaceIdRouterRuleTemplatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postWorkspacesByWorkspaceIdRouterRuleTemplates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postWorkspacesByWorkspaceIdRouterRuleTemplatesQueryKey(options)
    });
};

/**
 * Create Workspace Router Rule Template
 * Creates a new router rule template scoped to the specified workspace. Template names must be unique within the organization scope. The workspaceId from the URL path will be used to scope the template.
 */
export const postWorkspacesByWorkspaceIdRouterRuleTemplatesMutation = (options?: Partial<Options<PostWorkspacesByWorkspaceIdRouterRuleTemplatesData>>): UseMutationOptions<unknown, PostWorkspacesByWorkspaceIdRouterRuleTemplatesError, Options<PostWorkspacesByWorkspaceIdRouterRuleTemplatesData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostWorkspacesByWorkspaceIdRouterRuleTemplatesError, Options<PostWorkspacesByWorkspaceIdRouterRuleTemplatesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postWorkspacesByWorkspaceIdRouterRuleTemplates({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};