// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { PostAuthRegisterData, PostAuthRegisterResponse, PostAuthRegisterVerifyData, PostAuthRegisterVerifyResponse, PostAuthRegisterVerifyResendData, PostAuthRegisterVerifyResendResponse, PostAuthSignInData, PostAuthSignInResponse, PostAuthSignInVerifyData, PostAuthSignInVerifyResponse, PostAuthEmailVerifySendData, PostAuthEmailVerifySendResponse, PostAuthEmailVerifyData, PostAuthEmailVerifyResponse, GetAuthMeResponse, GetAuthSignOutResponse, PostAuthPasswordResetData, PostAuthPasswordResetResponse, PostAuthPasswordResetVerifyData, PostAuthPasswordResetVerifyResponse, PostAuthPasswordChangeData, PostAuthPasswordChangeResponse, PostApiKeysData, PostApiKeysResponse, GetApiKeysResponse, GetApiKeysByApiKeyIdData, GetApiKeysByApiKeyIdResponse, PutApiKeysByApiKeyIdData, PutApiKeysByApiKeyIdResponse, DeleteApiKeysByApiKeyIdData, DeleteApiKeysByApiKeyIdResponse, PutApiKeysByApiKeyIdStatusData, PutApiKeysByApiKeyIdStatusResponse, GetOrgsCurrentResponse, PutOrgsData, PutOrgsResponse, PostOrgsFirstData, PostOrgsFirstResponse, PostOrgsCurrentByOrgIdData, PostOrgsCurrentByOrgIdResponse, PostInvitesData, PostInvitesResponse, GetInvitesResponse, GetInvitesMeResponse, DeleteInvitesByInvitationIdData, DeleteInvitesByInvitationIdResponse, GetInvitesByTokenAcceptData, GetInvitesByTokenAcceptResponse, GetInvitesByTokenDeclineData, GetInvitesByTokenDeclineResponse, PostMembersData, PostMembersResponse, GetMembersResponse, DeleteMembersByUserIdData, DeleteMembersByUserIdResponse, GetMembersByUserIdRolesData, GetMembersByUserIdRolesResponse, PostMembersByUserIdRoleData, PostMembersByUserIdRoleResponse, DeleteMembersByUserIdRoleByRoleNameData, DeleteMembersByUserIdRoleByRoleNameResponse, PostWorkspacesData, PostWorkspacesResponse, GetWorkspacesResponse, GetWorkspacesByWorkspaceIdData, GetWorkspacesByWorkspaceIdResponse, PutWorkspacesByWorkspaceIdData, PutWorkspacesByWorkspaceIdResponse, DeleteWorkspacesByWorkspaceIdData, DeleteWorkspacesByWorkspaceIdResponse, GetWorkspacesByWorkspaceIdMembersByUserIdRoleData, GetWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, PostWorkspacesByWorkspaceIdMembersByUserIdRoleData, PostWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleData, DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleResponse, GetWorkspacesByWorkspaceIdMembersData, GetWorkspacesByWorkspaceIdMembersResponse, GetRolesData, GetRolesResponse, GetPlansResponse, GetPlansCurrentResponse, GetSettingsResponse, GetSettingsCustomResponse, PostSettingsCustomData, PostSettingsCustomResponse, GetSettingsCustomBySettingSlugData, GetSettingsCustomBySettingSlugResponse, PutSettingsCustomBySettingSlugData, PutSettingsCustomBySettingSlugResponse, DeleteSettingsCustomBySettingSlugData, DeleteSettingsCustomBySettingSlugResponse, GetSettingsCustomBySettingSlugValueData, GetSettingsCustomBySettingSlugValueResponse, GetSettingsServiceResponse, GetSettingsServiceBySettingSlugData, GetSettingsServiceBySettingSlugResponse, PutSettingsServiceBySettingSlugData, PutSettingsServiceBySettingSlugResponse, GetSettingsServiceBySettingSlugValueData, GetSettingsServiceBySettingSlugValueResponse, GetWorkspacesByWorkspaceIdSettingsData, GetWorkspacesByWorkspaceIdSettingsResponse, GetWorkspacesByWorkspaceIdSettingsCustomData, GetWorkspacesByWorkspaceIdSettingsCustomResponse, PostWorkspacesByWorkspaceIdSettingsCustomData, PostWorkspacesByWorkspaceIdSettingsCustomResponse, GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData, GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData, PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData, DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse, GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueData, GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueResponse, GetWorkspacesByWorkspaceIdSettingsServiceData, GetWorkspacesByWorkspaceIdSettingsServiceResponse, GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData, GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData, PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData, DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse, GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueData, GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueResponse, GetCodesByCodeIdScansData, GetCodesByCodeIdScansResponse, GetCodesByCodeIdRouterRulesData, GetCodesByCodeIdRouterRulesResponse, PostCodesByCodeIdRouterRulesData, PostCodesByCodeIdRouterRulesResponse, GetCodesByCodeIdRouterRulesByRouterRuleIdData, GetCodesByCodeIdRouterRulesByRouterRuleIdResponse, PutCodesByCodeIdRouterRulesByRouterRuleIdData, PutCodesByCodeIdRouterRulesByRouterRuleIdResponse, DeleteCodesByCodeIdRouterRulesByRouterRuleIdData, DeleteCodesByCodeIdRouterRulesByRouterRuleIdResponse, GetRouterRulesData, GetRouterRulesResponse, GetWorkspacesByWorkspaceIdRouterRulesData, GetWorkspacesByWorkspaceIdRouterRulesResponse, GetCodesDeletedData, GetCodesDeletedResponse, GetCodesByCodeIdData, GetCodesByCodeIdResponse, PutCodesByCodeIdData, PutCodesByCodeIdResponse, DeleteCodesByCodeIdData, DeleteCodesByCodeIdResponse, GetCodesData, GetCodesResponse, PostCodesData, PostCodesResponse, DeleteCodesResponse, PutCodesByCodeIdOptionsData, PutCodesByCodeIdOptionsResponse, DeleteCodesPermanentResponse, DeleteCodesByCodeIdPermanentData, DeleteCodesByCodeIdPermanentResponse, PostCodesByCodeIdRestoreData, PostCodesByCodeIdRestoreResponse, PostCodesValidateData, PostCodesValidateResponse, PostCodesByCodeIdValidateData, PostCodesByCodeIdValidateResponse, PostCodesLinksRefreshResponse, GetCodesLinksData, GetCodesLinksResponse, PostCodesGenerateByTypeData, PostCodesGenerateByTypeResponse, GetCodesByCodeIdVersionByVersionByTypeData, GetCodesByCodeIdVersionByVersionByTypeResponse, GetCodesByCodeIdVersionByVersionByTypeLinkData, GetCodesByCodeIdVersionByVersionByTypeLinkResponse, DeleteCodesByCodeIdVersionsByVersionLinksData, DeleteCodesByCodeIdVersionsByVersionLinksResponse, DeleteCodesByCodeIdVersionsByVersionLinksByTypeData, DeleteCodesByCodeIdVersionsByVersionLinksByTypeResponse, DeleteCodesByCodeIdVersionsLinksData, DeleteCodesByCodeIdVersionsLinksResponse, DeleteCodesByCodeIdVersionsLinksByTypeData, DeleteCodesByCodeIdVersionsLinksByTypeResponse, GetCodesByCodeIdByTypeData, GetCodesByCodeIdByTypeResponse, GetCodesByCodeIdByTypeLinkData, GetCodesByCodeIdByTypeLinkResponse, DeleteCodesByCodeIdLinksData, DeleteCodesByCodeIdLinksResponse, DeleteCodesByCodeIdLinksByTypeData, DeleteCodesByCodeIdLinksByTypeResponse, GetCodesByCodeIdVersionByVersionData, GetCodesByCodeIdVersionByVersionResponse, GetCodesByCodeIdVersionsData, GetCodesByCodeIdVersionsResponse, DeleteCodesByCodeIdVersionsData, DeleteCodesByCodeIdVersionsResponse, PostCodesByCodeIdVersionByVersionRestoreData, PostCodesByCodeIdVersionByVersionRestoreResponse, PostTemplatesData, PostTemplatesResponse, GetTemplatesData, GetTemplatesResponse2, GetTemplatesBaseData, GetTemplatesBaseResponse, GetTemplatesByTemplateIdData, GetTemplatesByTemplateIdResponse, PutTemplatesByTemplateIdData, PutTemplatesByTemplateIdResponse, DeleteTemplatesByTemplateIdData, DeleteTemplatesByTemplateIdResponse, PutTemplatesByTemplateIdOptionsData, PutTemplatesByTemplateIdOptionsResponse, GetTemplatesWorkspaceByWorkspaceIdData, GetTemplatesWorkspaceByWorkspaceIdResponse, PostStylesData, PostStylesResponse, GetStylesData, GetStylesResponse2, GetStylesBaseData, GetStylesBaseResponse, GetStylesByStyleIdData, GetStylesByStyleIdResponse, PutStylesByStyleIdData, PutStylesByStyleIdResponse, DeleteStylesByStyleIdData, DeleteStylesByStyleIdResponse, PutStylesByStyleIdOptionsData, PutStylesByStyleIdOptionsResponse, GetStylesWorkspaceByWorkspaceIdData, GetStylesWorkspaceByWorkspaceIdResponse, PostTextsData, PostTextsResponse, GetTextsData, GetTextsResponse2, GetTextsBaseData, GetTextsBaseResponse, GetTextsByTextIdData, GetTextsByTextIdResponse, PutTextsByTextIdData, PutTextsByTextIdResponse, DeleteTextsByTextIdData, DeleteTextsByTextIdResponse, PutTextsByTextIdOptionsData, PutTextsByTextIdOptionsResponse, GetTextsWorkspaceByWorkspaceIdData, GetTextsWorkspaceByWorkspaceIdResponse, PostBordersData, PostBordersResponse, GetBordersData, GetBordersResponse2, GetBordersBaseData, GetBordersBaseResponse, GetBordersByBorderIdData, GetBordersByBorderIdResponse, PutBordersByBorderIdData, PutBordersByBorderIdResponse, DeleteBordersByBorderIdData, DeleteBordersByBorderIdResponse, PutBordersByBorderIdOptionsData, PutBordersByBorderIdOptionsResponse, GetBordersWorkspaceByWorkspaceIdData, GetBordersWorkspaceByWorkspaceIdResponse, GetCountryCodesResponse, PostRouterRuleTemplatesData, PostRouterRuleTemplatesResponse, GetRouterRuleTemplatesData, GetRouterRuleTemplatesResponse, GetRouterRuleTemplatesByRouterRuleTemplateIdData, GetRouterRuleTemplatesByRouterRuleTemplateIdResponse, PutRouterRuleTemplatesByRouterRuleTemplateIdData, PutRouterRuleTemplatesByRouterRuleTemplateIdResponse, DeleteRouterRuleTemplatesByRouterRuleTemplateIdData, DeleteRouterRuleTemplatesByRouterRuleTemplateIdResponse, PostWorkspacesByWorkspaceIdRouterRuleTemplatesData, PostWorkspacesByWorkspaceIdRouterRuleTemplatesResponse } from './types.gen';

export class AuthService {
    /**
     * Register New User
     * Registers a new user and organization. Sends a verification code and token via email
     * @param data The data for the request.
     * @param data.requestBody
     * @returns RegisterResponse Registration initiated. Check email for verification
     * @throws ApiError
     */
    public static postAuthRegister(data: PostAuthRegisterData = {}): CancelablePromise<PostAuthRegisterResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/register',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request on registration'
            }
        });
    }
    
    /**
     * Verify Registration Code or Token
     * Verifies the 6-digit code or token sent via email after registration
     * @param data The data for the request.
     * @param data.requestBody
     * @returns RegisterVerifyResponse Registration verification successful
     * @throws ApiError
     */
    public static postAuthRegisterVerify(data: PostAuthRegisterVerifyData = {}): CancelablePromise<PostAuthRegisterVerifyResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/register-verify',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request on registration verification',
                401: 'Unauthorized',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Resend Registration Verification Code and Token
     * Resends the 6-digit verification code or token to the user's email.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns RegisterVerifyResendResponse Verification email resent successfully
     * @throws ApiError
     */
    public static postAuthRegisterVerifyResend(data: PostAuthRegisterVerifyResendData = {}): CancelablePromise<PostAuthRegisterVerifyResendResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/register-verify-resend',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request on resending registration verification',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Sign In User
     * Initiates user sign-in. Returns an access token if password is provided and correct, otherwise indicates if passwordless verification is needed
     * @param data The data for the request.
     * @param data.requestBody
     * @returns SignInResponse Sign-in successful or verification initiated
     * @throws ApiError
     */
    public static postAuthSignIn(data: PostAuthSignInData = {}): CancelablePromise<PostAuthSignInResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/sign-in',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request on sign-in',
                401: 'Unauthorized',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Verify Sign In Code or Token
     * Verifies the 6-digit code or token sent via email for passwordless sign-in
     * @param data The data for the request.
     * @param data.requestBody
     * @returns SignInVerifyResponse Sign-in verification successful
     * @throws ApiError
     */
    public static postAuthSignInVerify(data: PostAuthSignInVerifyData = {}): CancelablePromise<PostAuthSignInVerifyResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/sign-in-verify',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request on sign-in verification',
                401: 'Unauthorized',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Send Email Verification Code and Token
     * Sends a verification code and token to the user's email if it's not already verified.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns EmailVerifySendResponse Verification email sent successfully
     * @throws ApiError
     */
    public static postAuthEmailVerifySend(data: PostAuthEmailVerifySendData = {}): CancelablePromise<PostAuthEmailVerifySendResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/email-verify-send',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request on sending email verification',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Verify Email Address
     * Verifies the user's email address using the provided code or token.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns EmailVerifyResponse Email verification successful
     * @throws ApiError
     */
    public static postAuthEmailVerify(data: PostAuthEmailVerifyData = {}): CancelablePromise<PostAuthEmailVerifyResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/email-verify',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request on email verification',
                401: 'Unauthorized',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Get Current User
     * Retrieves the details of the currently authenticated user
     * @returns MeResponse Successfully retrieved user details
     * @throws ApiError
     */
    public static getAuthMe(): CancelablePromise<GetAuthMeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/auth/me',
            errors: {
                401: 'Unauthorized',
                404: 'Member not found, Organization context not found, or Member has no organizations.'
            }
        });
    }
    
    /**
     * Sign Out User
     * Signs out the current user by clearing relevant cookies/session data
     * @returns SignOutResponse Successfully signed out
     * @throws ApiError
     */
    public static getAuthSignOut(): CancelablePromise<GetAuthSignOutResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/auth/sign-out',
            errors: {
                400: 'Bad Request on sign-out',
                401: 'Unauthorized'
            }
        });
    }
    
}

export class PasswordManagementService {
    /**
     * Request Password Reset
     * Sends a password reset email with a verification token
     * @param data The data for the request.
     * @param data.requestBody
     * @returns PasswordResetResponse Password reset email sent
     * @throws ApiError
     */
    public static postAuthPasswordReset(data: PostAuthPasswordResetData = {}): CancelablePromise<PostAuthPasswordResetResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/password/reset',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to reset password.',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Verify Password Reset
     * Verifies the password reset token and sets a new password
     * @param data The data for the request.
     * @param data.requestBody
     * @returns PasswordResetVerifyResponse Password reset successful
     * @throws ApiError
     */
    public static postAuthPasswordResetVerify(data: PostAuthPasswordResetVerifyData = {}): CancelablePromise<PostAuthPasswordResetVerifyResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/password/reset-verify',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to verify password reset.',
                401: 'Unauthorized',
                404: 'User or organization not found'
            }
        });
    }
    
    /**
     * Change Password
     * Changes the password for the authenticated user
     * @param data The data for the request.
     * @param data.requestBody
     * @returns PasswordChangeResponse Password changed successfully
     * @throws ApiError
     */
    public static postAuthPasswordChange(data: PostAuthPasswordChangeData = {}): CancelablePromise<PostAuthPasswordChangeResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/password/change',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to change password.',
                401: 'Unauthorized',
                404: 'User or organization not found'
            }
        });
    }
    
}

export class ApiKeysService {
    /**
     * Create API key
     * Creates a new API key for the current organization.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns ApiKeyCreateResponse API key created successfully
     * @throws ApiError
     */
    public static postApiKeys(data: PostApiKeysData = {}): CancelablePromise<PostApiKeysResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api-keys',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when creating API key',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found.',
                409: 'Conflict',
                429: 'You have reached the limit for limit-api-keys. Please upgrade your plan to continue'
            }
        });
    }
    
    /**
     * List API keys
     * Retrieves all API keys for the current organization.
     * @returns ApiKeyList List of API keys
     * @throws ApiError
     */
    public static getApiKeys(): CancelablePromise<GetApiKeysResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api-keys',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found or no API keys found for the organization.'
            }
        });
    }
    
    /**
     * Get API key details
     * Retrieves details of a specific API key by its ID.
     * @param data The data for the request.
     * @param data.apiKeyId Unique identifier of the API key
     * @returns ApiKeyResponse API key details
     * @throws ApiError
     */
    public static getApiKeysByApiKeyId(data: GetApiKeysByApiKeyIdData): CancelablePromise<GetApiKeysByApiKeyIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api-keys/{apiKeyId}',
            path: {
                apiKeyId: data.apiKeyId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'API key not found or its organization not found.'
            }
        });
    }
    
    /**
     * Update API key
     * Updates an existing API key by its ID.
     * @param data The data for the request.
     * @param data.apiKeyId Unique identifier of the API key
     * @param data.requestBody
     * @returns ApiKeyResponse API key updated successfully
     * @throws ApiError
     */
    public static putApiKeysByApiKeyId(data: PutApiKeysByApiKeyIdData): CancelablePromise<PutApiKeysByApiKeyIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/api-keys/{apiKeyId}',
            path: {
                apiKeyId: data.apiKeyId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating API key',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'API key to update not found or its organization not found.'
            }
        });
    }
    
    /**
     * Delete API key
     * Deletes an API key by its ID.
     * @param data The data for the request.
     * @param data.apiKeyId Unique identifier of the API key
     * @returns SuccessResponse API key deleted successfully
     * @throws ApiError
     */
    public static deleteApiKeysByApiKeyId(data: DeleteApiKeysByApiKeyIdData): CancelablePromise<DeleteApiKeysByApiKeyIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/api-keys/{apiKeyId}',
            path: {
                apiKeyId: data.apiKeyId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'API key to delete not found or its organization not found.'
            }
        });
    }
    
    /**
     * Change API key status
     * Changes the status of an API key (activate or disable).
     * @param data The data for the request.
     * @param data.apiKeyId Unique identifier of the API key
     * @param data.requestBody
     * @returns ApiKeyResponse API key status changed successfully
     * @throws ApiError
     */
    public static putApiKeysByApiKeyIdStatus(data: PutApiKeysByApiKeyIdStatusData): CancelablePromise<PutApiKeysByApiKeyIdStatusResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/api-keys/{apiKeyId}/status',
            path: {
                apiKeyId: data.apiKeyId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when changing API key status',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'API key to change status not found or its organization not found.'
            }
        });
    }
    
}

export class OrganizationsService {
    /**
     * Get current organization
     * Retrieves details of the current active organization for the authenticated user.
     * @returns OrganizationResponse Current organization details
     * @throws ApiError
     */
    public static getOrgsCurrent(): CancelablePromise<GetOrgsCurrentResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/orgs/current',
            errors: {
                401: 'Unauthorized',
                404: 'The current organization was not found.'
            }
        });
    }
    
    /**
     * Update current organization
     * Updates the details of the current active organization.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns OrganizationResponse Organization updated successfully
     * @throws ApiError
     */
    public static putOrgs(data: PutOrgsData = {}): CancelablePromise<PutOrgsResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/orgs',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to update organization. Check data, permissions, or ensure at least one field is provided for update.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'The organization to update was not found.'
            }
        });
    }
    
    /**
     * Create first organization
     * Creates the first organization for a new user. Only works when the user has no organizations.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns OrganizationCreateResponse First organization created successfully
     * @throws ApiError
     */
    public static postOrgsFirst(data: PostOrgsFirstData = {}): CancelablePromise<PostOrgsFirstResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/first',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to create first organization.',
                401: 'Unauthorized',
                409: 'Conflict'
            }
        });
    }
    
    /**
     * Switch current organization
     * Switches the current active organization for the authenticated user.
     * @param data The data for the request.
     * @param data.orgId Unique identifier of the organization
     * @returns SignInVerifyResponse Organization switched successfully
     * @throws ApiError
     */
    public static postOrgsCurrentByOrgId(data: PostOrgsCurrentByOrgIdData): CancelablePromise<PostOrgsCurrentByOrgIdResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/orgs/current/{orgId}',
            path: {
                orgId: data.orgId
            },
            errors: {
                401: 'Unauthorized',
                404: 'Target organization for switching not found or is disabled.'
            }
        });
    }
    
}

export class InvitationsService {
    /**
     * Create invitation
     * Creates a new invitation to join the organization with a specified role.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns CreateInvitationResponse Invitation created successfully
     * @throws ApiError
     */
    public static postInvites(data: PostInvitesData = {}): CancelablePromise<PostInvitesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/invites',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to create invitation.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found.',
                409: 'Conflict',
                429: 'You have reached the limit for limit-members. Please upgrade your plan to continue'
            }
        });
    }
    
    /**
     * List organization invitations
     * Retrieves all invitations for the current organization.
     * @returns OrganizationInvitationsResponse List of invitations
     * @throws ApiError
     */
    public static getInvites(): CancelablePromise<GetInvitesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/invites',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization context not found.'
            }
        });
    }
    
    /**
     * List my invitations
     * Retrieves all invitations sent by the current user.
     * @returns UserInvitationsResponse List of invitations sent by the current user
     * @throws ApiError
     */
    public static getInvitesMe(): CancelablePromise<GetInvitesMeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/invites/me',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'No invitations found for the current user, or the organization context is invalid.'
            }
        });
    }
    
    /**
     * Delete invitation
     * Deletes an invitation by its ID.
     * @param data The data for the request.
     * @param data.invitationId Unique identifier of the invitation
     * @returns unknown Invitation deleted successfully
     * @throws ApiError
     */
    public static deleteInvitesByInvitationId(data: DeleteInvitesByInvitationIdData): CancelablePromise<DeleteInvitesByInvitationIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/invites/{invitationId}',
            path: {
                invitationId: data.invitationId
            },
            errors: {
                400: 'Cannot delete invitation due to invalid parameters or business rules.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Invitation to delete not found, or its organization not found.'
            }
        });
    }
    
    /**
     * Accept invitation
     * Accepts an invitation using the provided token. Creates a user account if needed.
     * @param data The data for the request.
     * @param data.token
     * @returns AcceptInvitationResponse Invitation accepted successfully
     * @throws ApiError
     */
    public static getInvitesByTokenAccept(data: GetInvitesByTokenAcceptData): CancelablePromise<GetInvitesByTokenAcceptResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/invites/{token}/accept',
            path: {
                token: data.token
            },
            errors: {
                400: 'Cannot accept invitation due to invalid token, status, or parameters.',
                404: 'Invitation to accept not found or has an invalid status (e.g., already accepted/declined/expired). '
            }
        });
    }
    
    /**
     * Decline invitation
     * Declines an invitation using the provided token.
     * @param data The data for the request.
     * @param data.token Invitation token
     * @returns unknown Invitation declined successfully
     * @throws ApiError
     */
    public static getInvitesByTokenDecline(data: GetInvitesByTokenDeclineData): CancelablePromise<GetInvitesByTokenDeclineResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/invites/{token}/decline',
            path: {
                token: data.token
            },
            errors: {
                400: 'Cannot decline invitation due to invalid token, status, or parameters.',
                404: 'Invitation to decline not found or has an invalid status (e.g., already accepted/declined/expired). '
            }
        });
    }
    
}

export class MembersService {
    /**
     * Add a member to organization
     * Adds a new member to the current organization with the specified role.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserRoleWithOrganization Member added successfully
     * @throws ApiError
     */
    public static postMembers(data: PostMembersData = {}): CancelablePromise<PostMembersResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/members',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to add member.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Member to be added not found (and invitation not sent), or Organization not found.',
                409: 'Conflict'
            }
        });
    }
    
    /**
     * List organization members
     * Retrieves all members of the current organization.
     * @returns OrganizationMembers List of organization members
     * @throws ApiError
     */
    public static getMembers(): CancelablePromise<GetMembersResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/members',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or no members in organization.'
            }
        });
    }
    
    /**
     * Remove member from organization
     * Removes a member from the current organization.
     * @param data The data for the request.
     * @param data.userId
     * @returns unknown Member removed from organization successfully
     * @throws ApiError
     */
    public static deleteMembersByUserId(data: DeleteMembersByUserIdData): CancelablePromise<DeleteMembersByUserIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/members/{userId}',
            path: {
                userId: data.userId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Member to remove not found in the organization, or Organization not found.'
            }
        });
    }
    
    /**
     * Get member roles
     * Retrieves all roles assigned to a member in the current organization.
     * @param data The data for the request.
     * @param data.userId
     * @returns GroupedMemberRoles Member roles
     * @throws ApiError
     */
    public static getMembersByUserIdRoles(data: GetMembersByUserIdRolesData): CancelablePromise<GetMembersByUserIdRolesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/members/{userId}/roles',
            path: {
                userId: data.userId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Member not found, Organization not found, or member found but has no roles in this context.'
            }
        });
    }
    
    /**
     * Add role to member
     * Assigns a new role to a member in the current organization.
     * @param data The data for the request.
     * @param data.userId
     * @param data.requestBody
     * @returns UserRoleWithOrganization Role added successfully
     * @throws ApiError
     */
    public static postMembersByUserIdRole(data: PostMembersByUserIdRoleData): CancelablePromise<PostMembersByUserIdRoleResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/members/{userId}/role',
            path: {
                userId: data.userId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to add role to member.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Member, Role, or Organization not found.'
            }
        });
    }
    
    /**
     * Remove role from member
     * Removes a role from a member in the current organization.
     * @param data The data for the request.
     * @param data.userId
     * @param data.roleName Name of the role
     * @returns unknown Role removed from member successfully
     * @throws ApiError
     */
    public static deleteMembersByUserIdRoleByRoleName(data: DeleteMembersByUserIdRoleByRoleNameData): CancelablePromise<DeleteMembersByUserIdRoleByRoleNameResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/members/{userId}/role/{roleName}',
            path: {
                userId: data.userId,
                roleName: data.roleName
            },
            errors: {
                400: 'Cannot remove member role due to business rules or invalid parameters.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Member, Role, or Organization not found.'
            }
        });
    }
    
}

export class WorkspacesService {
    /**
     * Create a new workspace
     * Creates a new workspace in the current organization.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns WorkspaceResponse Workspace created successfully
     * @throws ApiError
     */
    public static postWorkspaces(data: PostWorkspacesData = {}): CancelablePromise<PostWorkspacesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/workspaces',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid input for creating a workspace.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found.',
                429: 'You have reached the limit for limit-workspaces. Please upgrade your plan to continue'
            }
        });
    }
    
    /**
     * List workspaces
     * Retrieves all workspaces for the current organization.
     * @returns WorkspaceResponse List of workspaces
     * @throws ApiError
     */
    public static getWorkspaces(): CancelablePromise<GetWorkspacesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces',
            errors: {
                400: 'Invalid request for listing workspaces.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found or no workspaces exist.'
            }
        });
    }
    
    /**
     * Get workspace by ID
     * Retrieves a specific workspace by its unique identifier.
     * @param data The data for the request.
     * @param data.workspaceId
     * @returns WorkspaceResponse Workspace details
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceId(data: GetWorkspacesByWorkspaceIdData): CancelablePromise<GetWorkspacesByWorkspaceIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}',
            path: {
                workspaceId: data.workspaceId
            },
            errors: {
                400: 'Invalid request for getting a workspace.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace or Organization not found.'
            }
        });
    }
    
    /**
     * Update workspace
     * Updates an existing workspace by its unique identifier.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.requestBody
     * @returns WorkspaceResponse Workspace updated successfully
     * @throws ApiError
     */
    public static putWorkspacesByWorkspaceId(data: PutWorkspacesByWorkspaceIdData): CancelablePromise<PutWorkspacesByWorkspaceIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/workspaces/{workspaceId}',
            path: {
                workspaceId: data.workspaceId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid input for updating a workspace.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace or Organization not found.'
            }
        });
    }
    
    /**
     * Delete workspace
     * Deletes a workspace by its unique identifier.
     * @param data The data for the request.
     * @param data.workspaceId
     * @returns WorkspaceDeleteResponse Workspace deleted successfully
     * @throws ApiError
     */
    public static deleteWorkspacesByWorkspaceId(data: DeleteWorkspacesByWorkspaceIdData): CancelablePromise<DeleteWorkspacesByWorkspaceIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/workspaces/{workspaceId}',
            path: {
                workspaceId: data.workspaceId
            },
            errors: {
                400: 'Invalid request for deleting a workspace.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace or Organization not found.'
            }
        });
    }
    
    /**
     * Get user roles in workspace
     * Retrieves the roles assigned to a specific user in a workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.userId Unique identifier of the user
     * @returns WorkspaceMemberRoles User roles in the workspace
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdMembersByUserIdRole(data: GetWorkspacesByWorkspaceIdMembersByUserIdRoleData): CancelablePromise<GetWorkspacesByWorkspaceIdMembersByUserIdRoleResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/members/{userId}/role',
            path: {
                workspaceId: data.workspaceId,
                userId: data.userId
            },
            errors: {
                400: 'Invalid request for getting user roles in a workspace.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace, Member, or Organization not found.'
            }
        });
    }
    
    /**
     * Add role to workspace member
     * Assigns a role to a user in a specific workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.userId
     * @param data.requestBody
     * @returns AddWorkspaceMemberRoleResponse Role added successfully
     * @throws ApiError
     */
    public static postWorkspacesByWorkspaceIdMembersByUserIdRole(data: PostWorkspacesByWorkspaceIdMembersByUserIdRoleData): CancelablePromise<PostWorkspacesByWorkspaceIdMembersByUserIdRoleResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/workspaces/{workspaceId}/members/{userId}/role',
            path: {
                workspaceId: data.workspaceId,
                userId: data.userId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid input for adding a role to a workspace member.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace, Member, Role or Organization not found.'
            }
        });
    }
    
    /**
     * Remove role from workspace member
     * Removes a role from a user in a specific workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.userId
     * @returns unknown Role removed from user in workspace successfully
     * @throws ApiError
     */
    public static deleteWorkspacesByWorkspaceIdMembersByUserIdRole(data: DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleData): CancelablePromise<DeleteWorkspacesByWorkspaceIdMembersByUserIdRoleResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/workspaces/{workspaceId}/members/{userId}/role',
            path: {
                workspaceId: data.workspaceId,
                userId: data.userId
            },
            errors: {
                400: 'Invalid input for removing a role from a workspace member.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace, Member, Role or Organization not found.'
            }
        });
    }
    
    /**
     * List workspace members
     * Retrieves all members in a specific workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @returns WorkspaceMembers List of workspace members
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdMembers(data: GetWorkspacesByWorkspaceIdMembersData): CancelablePromise<GetWorkspacesByWorkspaceIdMembersResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/members',
            path: {
                workspaceId: data.workspaceId
            },
            errors: {
                400: 'Invalid request for listing workspace members.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace or Organization not found, or workspace has no members.'
            }
        });
    }
    
}

export class RolesService {
    /**
     * List all roles
     * Retrieves all system roles with their associated permission scopes.
     * @param data The data for the request.
     * @param data.includeScopes Include detailed scope information for each role
     * @returns RolesWithScopesResponse List of roles with their scopes
     * @throws ApiError
     */
    public static getRoles(data: GetRolesData = {}): CancelablePromise<GetRolesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/roles',
            query: {
                includeScopes: data.includeScopes
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found or no roles defined (system roles should always exist).'
            }
        });
    }
    
}

export class PlansService {
    /**
     * List available plans
     * Retrieves all available plans. If authenticated, the current plan will be marked.
     * @returns PlansResponse List of available plans
     * @throws ApiError
     */
    public static getPlans(): CancelablePromise<GetPlansResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/plans',
            errors: {
                404: 'No plans found globally (returns empty array if successful but no plans exist), or the organization context was not found if authenticated.'
            }
        });
    }
    
    /**
     * Get current plan
     * Retrieves the current plan for the authenticated organization with usage details.
     * @returns OrganizationPlanResponse Current organization plan with usage details
     * @throws ApiError
     */
    public static getPlansCurrent(): CancelablePromise<GetPlansCurrentResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/plans/current',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Plan for the current organization not found (this usually implies the organization itself was not found or has no plan).'
            }
        });
    }
    
}

export class SettingsService {
    /**
     * Get all organization settings
     * Retrieves all settings (custom and service) for the organization.
     * @returns SettingsWithGroupResponse List of all settings with group information
     * @throws ApiError
     */
    public static getSettings(): CancelablePromise<GetSettingsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/settings',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or no settings available.'
            }
        });
    }
    
    /**
     * Get all custom settings
     * Retrieves all custom settings for the organization.
     * @returns SettingsResponse List of custom settings
     * @throws ApiError
     */
    public static getSettingsCustom(): CancelablePromise<GetSettingsCustomResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/settings/custom',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or no custom settings available.'
            }
        });
    }
    
    /**
     * Create custom setting
     * Creates a new custom setting for the organization.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns SettingResponse Custom setting created successfully
     * @throws ApiError
     */
    public static postSettingsCustom(data: PostSettingsCustomData = {}): CancelablePromise<PostSettingsCustomResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/settings/custom',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when creating custom setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found.'
            }
        });
    }
    
    /**
     * Get custom setting by slug
     * Retrieves a specific custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @returns SettingResponse Custom setting details
     * @throws ApiError
     */
    public static getSettingsCustomBySettingSlug(data: GetSettingsCustomBySettingSlugData): CancelablePromise<GetSettingsCustomBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/settings/custom/{settingSlug}',
            path: {
                settingSlug: data.settingSlug
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Setting not found.'
            }
        });
    }
    
    /**
     * Update custom setting
     * Updates an existing custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.requestBody
     * @returns SettingResponse Custom setting updated successfully
     * @throws ApiError
     */
    public static putSettingsCustomBySettingSlug(data: PutSettingsCustomBySettingSlugData): CancelablePromise<PutSettingsCustomBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/settings/custom/{settingSlug}',
            path: {
                settingSlug: data.settingSlug
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating custom setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Setting not found.'
            }
        });
    }
    
    /**
     * Delete custom setting
     * Deletes a custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @returns SettingSuccessResponse Custom setting deleted successfully
     * @throws ApiError
     */
    public static deleteSettingsCustomBySettingSlug(data: DeleteSettingsCustomBySettingSlugData): CancelablePromise<DeleteSettingsCustomBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/settings/custom/{settingSlug}',
            path: {
                settingSlug: data.settingSlug
            },
            errors: {
                400: 'Bad Request when deleting custom setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Setting not found.'
            }
        });
    }
    
    /**
     * Get custom setting value
     * Retrieves only the value of a specific custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @returns string Custom setting value (any type)
     * @throws ApiError
     */
    public static getSettingsCustomBySettingSlugValue(data: GetSettingsCustomBySettingSlugValueData): CancelablePromise<GetSettingsCustomBySettingSlugValueResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/settings/custom/{settingSlug}/value',
            path: {
                settingSlug: data.settingSlug
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Setting not found.'
            }
        });
    }
    
    /**
     * Get all service settings
     * Retrieves all service settings for the organization.
     * @returns SettingsResponse List of service settings
     * @throws ApiError
     */
    public static getSettingsService(): CancelablePromise<GetSettingsServiceResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/settings/service',
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or no service settings available.'
            }
        });
    }
    
    /**
     * Get service setting by slug
     * Retrieves a specific service setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @returns SettingResponse Service setting details
     * @throws ApiError
     */
    public static getSettingsServiceBySettingSlug(data: GetSettingsServiceBySettingSlugData): CancelablePromise<GetSettingsServiceBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/settings/service/{settingSlug}',
            path: {
                settingSlug: data.settingSlug
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Service Setting not found.'
            }
        });
    }
    
    /**
     * Upsert service setting
     * Updates an existing service setting or creates it if it does not exist.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.requestBody
     * @returns SettingResponse Service setting updated successfully
     * @throws ApiError
     */
    public static putSettingsServiceBySettingSlug(data: PutSettingsServiceBySettingSlugData): CancelablePromise<PutSettingsServiceBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/settings/service/{settingSlug}',
            path: {
                settingSlug: data.settingSlug
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when upserting service setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Setting not found.'
            }
        });
    }
    
    /**
     * Get service setting value
     * Retrieves only the value of a specific service setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @returns unknown Service setting value (any type)
     * @throws ApiError
     */
    public static getSettingsServiceBySettingSlugValue(data: GetSettingsServiceBySettingSlugValueData): CancelablePromise<GetSettingsServiceBySettingSlugValueResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/settings/service/{settingSlug}/value',
            path: {
                settingSlug: data.settingSlug
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Service Setting not found.'
            }
        });
    }
    
}

export class WorkspaceSettingsService {
    /**
     * Get all workspace settings
     * Retrieves all settings (custom and service) for the workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @returns SettingsWithGroupResponse List of all workspace settings with group information
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdSettings(data: GetWorkspacesByWorkspaceIdSettingsData): CancelablePromise<GetWorkspacesByWorkspaceIdSettingsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/settings',
            path: {
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or no workspace settings found for any workspace in the org.'
            }
        });
    }
    
    /**
     * Get all workspace custom settings
     * Retrieves all custom settings for the workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @returns SettingsResponse List of workspace custom settings
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdSettingsCustom(data: GetWorkspacesByWorkspaceIdSettingsCustomData): CancelablePromise<GetWorkspacesByWorkspaceIdSettingsCustomResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/settings/custom',
            path: {
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or no custom settings available.'
            }
        });
    }
    
    /**
     * Create workspace custom setting
     * Creates a new custom setting for the workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.requestBody
     * @returns SettingResponse Workspace custom setting created successfully
     * @throws ApiError
     */
    public static postWorkspacesByWorkspaceIdSettingsCustom(data: PostWorkspacesByWorkspaceIdSettingsCustomData): CancelablePromise<PostWorkspacesByWorkspaceIdSettingsCustomResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/workspaces/{workspaceId}/settings/custom',
            path: {
                workspaceId: data.workspaceId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when creating custom setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Workspace not found.'
            }
        });
    }
    
    /**
     * Get workspace custom setting by slug
     * Retrieves a specific workspace custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @returns SettingResponse Workspace custom setting details
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdSettingsCustomBySettingSlug(data: GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData): CancelablePromise<GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Setting not found.'
            }
        });
    }
    
    /**
     * Update workspace custom setting
     * Updates an existing workspace custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @param data.requestBody
     * @returns SettingResponse Workspace custom setting updated successfully
     * @throws ApiError
     */
    public static putWorkspacesByWorkspaceIdSettingsCustomBySettingSlug(data: PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData): CancelablePromise<PutWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating custom setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, Workspace, or Setting not found.'
            }
        });
    }
    
    /**
     * Delete workspace custom setting
     * Deletes a workspace custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @returns SettingSuccessResponse Workspace custom setting deleted successfully
     * @throws ApiError
     */
    public static deleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlug(data: DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugData): CancelablePromise<DeleteWorkspacesByWorkspaceIdSettingsCustomBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            errors: {
                400: 'Bad Request when deleting custom setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, Workspace, or Setting not found.'
            }
        });
    }
    
    /**
     * Get workspace custom setting value
     * Retrieves only the value of a specific workspace custom setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @returns unknown Workspace custom setting value (any type)
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValue(data: GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueData): CancelablePromise<GetWorkspacesByWorkspaceIdSettingsCustomBySettingSlugValueResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/settings/custom/{settingSlug}/value',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Setting not found.'
            }
        });
    }
    
    /**
     * Get all workspace service settings
     * Retrieves all service settings for the workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @returns SettingsResponse List of workspace service settings
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdSettingsService(data: GetWorkspacesByWorkspaceIdSettingsServiceData): CancelablePromise<GetWorkspacesByWorkspaceIdSettingsServiceResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/settings/service',
            path: {
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or no service settings available.'
            }
        });
    }
    
    /**
     * Get workspace service setting by slug
     * Retrieves a specific workspace service setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @returns SettingResponse Workspace service setting details
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdSettingsServiceBySettingSlug(data: GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData): CancelablePromise<GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/settings/service/{settingSlug}',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, Workspace, or Service Setting not found.'
            }
        });
    }
    
    /**
     * Upsert workspace service setting
     * Updates an existing workspace service setting or creates it if it does not exist.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @param data.requestBody
     * @returns SettingResponse Workspace service setting updated successfully
     * @throws ApiError
     */
    public static putWorkspacesByWorkspaceIdSettingsServiceBySettingSlug(data: PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData): CancelablePromise<PutWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/workspaces/{workspaceId}/settings/service/{settingSlug}',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when upserting service setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, Workspace, or Setting not found.'
            }
        });
    }
    
    /**
     * Delete workspace service setting override
     * Deletes a workspace-level override for a service setting, reverting to organization defaults.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @returns SettingSuccessResponse Overridden workspace service setting deleted successfully
     * @throws ApiError
     */
    public static deleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlug(data: DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugData): CancelablePromise<DeleteWorkspacesByWorkspaceIdSettingsServiceBySettingSlugResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/workspaces/{workspaceId}/settings/service/{settingSlug}',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            errors: {
                400: 'Bad Request when deleting overridden workspace service setting',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, Workspace, or Setting not found.'
            }
        });
    }
    
    /**
     * Get workspace service setting value
     * Retrieves only the value of a specific workspace service setting by its slug.
     * @param data The data for the request.
     * @param data.settingSlug
     * @param data.workspaceId
     * @returns unknown Workspace service setting value (any type)
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValue(data: GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueData): CancelablePromise<GetWorkspacesByWorkspaceIdSettingsServiceBySettingSlugValueResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/settings/service/{settingSlug}/value',
            path: {
                settingSlug: data.settingSlug,
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, Workspace, or Service Setting not found.'
            }
        });
    }
    
}

export class QrCodeScansService {
    /**
     * List QR Code Scans
     * Retrieves a paginated list of scans for a specific QR Code with optional filtering
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.page Page number for pagination
     * @param data.limit Number of items per page
     * @param data.orderBy Field to order results by
     * @param data.orderDirection Direction of ordering
     * @param data.browser
     * @param data.os
     * @param data.countryCode
     * @param data.city
     * @param data.region
     * @param data.continent
     * @param data.asOrganization
     * @param data.status
     * @param data.scannedAt
     * @returns unknown A paginated list of QR Code Scans
     * @throws ApiError
     */
    public static getCodesByCodeIdScans(data: GetCodesByCodeIdScansData): CancelablePromise<GetCodesByCodeIdScansResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/scans',
            path: {
                codeId: data.codeId
            },
            query: {
                page: data.page,
                limit: data.limit,
                orderBy: data.orderBy,
                orderDirection: data.orderDirection,
                browser: data.browser,
                os: data.os,
                countryCode: data.countryCode,
                city: data.city,
                region: data.region,
                continent: data.continent,
                asOrganization: data.asOrganization,
                status: data.status,
                scannedAt: data.scannedAt
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, code, or scans not found.'
            }
        });
    }
    
}

export class QrCodeRouterRulesService {
    /**
     * List Router Rule Assignments
     * Retrieves all router rule assignments for a specific QR code with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR code
     * @param data.page Page number for pagination
     * @param data.limit Number of items to return (1-100)
     * @param data.includeDisabled Include disabled rules in results
     * @param data.type Filter rules by router rule type
     * @param data.priority Filter rules by specific priority value
     * @param data.dataType Filter rules by data type
     * @returns unknown A paginated list of Router Rule assignments with enriched template data
     * @throws ApiError
     */
    public static getCodesByCodeIdRouterRules(data: GetCodesByCodeIdRouterRulesData): CancelablePromise<GetCodesByCodeIdRouterRulesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/router-rules',
            path: {
                codeId: data.codeId
            },
            query: {
                page: data.page,
                limit: data.limit,
                includeDisabled: data.includeDisabled,
                type: data.type,
                priority: data.priority,
                dataType: data.dataType
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'QR code not found'
            }
        });
    }
    
    /**
     * Create Router Rule Assignment
     * Assigns a router rule to a QR code. You can reference an existing template by ID/name or create an inline custom rule. Rules with the same priority are evaluated in creation order. Scan limits and loop functionality are supported.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR code
     * @param data.requestBody Router Rule assignment creation data
     * @returns CodeRouterRuleResponse Router Rule assignment created successfully
     * @throws ApiError
     */
    public static postCodesByCodeIdRouterRules(data: PostCodesByCodeIdRouterRulesData): CancelablePromise<PostCodesByCodeIdRouterRulesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes/{codeId}/router-rules',
            path: {
                codeId: data.codeId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request data, priority conflict, or template not found',
                401: 'Unauthorized',
                403: 'Forbidden',
                429: 'You have reached the limit for router rules per QR code. Please upgrade your plan to continue'
            }
        });
    }
    
    /**
     * Get Router Rule Assignment
     * Retrieves a specific router rule assignment for a QR code. Returns the rule with enriched template data, usage statistics, and audit information.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR code
     * @param data.routerRuleId Unique identifier of the router rule
     * @returns CodeRouterRuleResponse Router Rule assignment details with enriched template data
     * @throws ApiError
     */
    public static getCodesByCodeIdRouterRulesByRouterRuleId(data: GetCodesByCodeIdRouterRulesByRouterRuleIdData): CancelablePromise<GetCodesByCodeIdRouterRulesByRouterRuleIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/router-rules/{routerRuleId}',
            path: {
                codeId: data.codeId,
                routerRuleId: data.routerRuleId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Router rule or QR code not found'
            }
        });
    }
    
    /**
     * Update Router Rule Assignment
     * Updates a router rule assignment. You can change the rule source (template vs inline), priority, data configuration, and other settings. Validation is context-aware and will validate dynamicData against the existing or provided dataType. Priority conflicts are checked.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR code
     * @param data.routerRuleId Unique identifier of the router rule assignment
     * @param data.requestBody Router Rule assignment update data
     * @returns CodeRouterRuleResponse Router Rule assignment updated successfully
     * @throws ApiError
     */
    public static putCodesByCodeIdRouterRulesByRouterRuleId(data: PutCodesByCodeIdRouterRulesByRouterRuleIdData): CancelablePromise<PutCodesByCodeIdRouterRulesByRouterRuleIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/codes/{codeId}/router-rules/{routerRuleId}',
            path: {
                codeId: data.codeId,
                routerRuleId: data.routerRuleId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request data, priority conflict, or validation error',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Router rule assignment not found, or QR code/organization/workspace context not found.'
            }
        });
    }
    
    /**
     * Delete Router Rule Assignment
     * Deletes a router rule assignment. Rules that have been used (totalScans > 0) cannot be deleted to preserve analytics data. Consider disabling the rule instead.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR code
     * @param data.routerRuleId Unique identifier of the router rule assignment
     * @returns unknown Router Rule assignment deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdRouterRulesByRouterRuleId(data: DeleteCodesByCodeIdRouterRulesByRouterRuleIdData): CancelablePromise<DeleteCodesByCodeIdRouterRulesByRouterRuleIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/router-rules/{routerRuleId}',
            path: {
                codeId: data.codeId,
                routerRuleId: data.routerRuleId
            },
            errors: {
                400: 'Rule has been used and cannot be deleted',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Router rule assignment not found, or QR code/organization/workspace context not found.'
            }
        });
    }
    
    /**
     * List Organization Router Rules
     * Retrieves all router rules across the organization. Users with organization-level access see all rules, while workspace-limited users see only rules from their permitted workspaces.
     * @param data The data for the request.
     * @param data.page Page number for pagination
     * @param data.limit Number of items to return (1-100)
     * @param data.includeDisabled Include disabled rules in results
     * @param data.type Filter rules by router rule type
     * @param data.priority Filter rules by specific priority value
     * @param data.dataType Filter rules by data type
     * @param data.workspaceId Filter by specific workspace ID
     * @param data.codeId Filter by specific QR code ID
     * @returns unknown A paginated list of organization router rules with code and workspace context
     * @throws ApiError
     */
    public static getRouterRules(data: GetRouterRulesData = {}): CancelablePromise<GetRouterRulesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/router-rules',
            query: {
                page: data.page,
                limit: data.limit,
                includeDisabled: data.includeDisabled,
                type: data.type,
                priority: data.priority,
                dataType: data.dataType,
                workspaceId: data.workspaceId,
                codeId: data.codeId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden'
            }
        });
    }
    
    /**
     * List Workspace Router Rule Assignments
     * Retrieves all router rule assignments within a specific workspace with pagination and filtering options. Returns rules sorted by priority (highest first) with enriched template data and QR code context.
     * @param data The data for the request.
     * @param data.workspaceId Unique identifier of the workspace
     * @param data.page Page number for pagination
     * @param data.limit Number of items to return (1-100)
     * @param data.includeDisabled Include disabled rules in results
     * @param data.type Filter rules by router rule type
     * @param data.priority Filter rules by specific priority value
     * @param data.dataType Filter rules by data type
     * @param data.codeId Filter rules by specific QR code ID within the workspace
     * @returns unknown A paginated list of workspace Router Rule assignments with QR code context
     * @throws ApiError
     */
    public static getWorkspacesByWorkspaceIdRouterRules(data: GetWorkspacesByWorkspaceIdRouterRulesData): CancelablePromise<GetWorkspacesByWorkspaceIdRouterRulesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/workspaces/{workspaceId}/router-rules',
            path: {
                workspaceId: data.workspaceId
            },
            query: {
                page: data.page,
                limit: data.limit,
                includeDisabled: data.includeDisabled,
                type: data.type,
                priority: data.priority,
                dataType: data.dataType,
                codeId: data.codeId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Workspace not found or no access'
            }
        });
    }
    
}

export class QrCodesService {
    /**
     * List Soft Deleted QR Codes
     * Retrieves a paginated list of soft deleted QR Codes with optional filtering
     * @param data The data for the request.
     * @param data.page Page number for pagination
     * @param data.limit Number of items per page
     * @param data.orderBy Field to order results by
     * @param data.orderDirection Direction of ordering
     * @param data.name
     * @param data.workspaceId
     * @param data.isValid
     * @param data.data
     * @param data.createdAt
     * @param data.updatedAt
     * @returns unknown A paginated list of soft deleted QR Codes
     * @throws ApiError
     */
    public static getCodesDeleted(data: GetCodesDeletedData = {}): CancelablePromise<GetCodesDeletedResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/deleted',
            query: {
                page: data.page,
                limit: data.limit,
                orderBy: data.orderBy,
                orderDirection: data.orderDirection,
                name: data.name,
                workspaceId: data.workspaceId,
                isValid: data.isValid,
                data: data.data,
                createdAt: data.createdAt,
                updatedAt: data.updatedAt
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or the list of codes is empty (returned as an empty paginated response).'
            }
        });
    }
    
    /**
     * Get QR Code
     * Retrieves a QR Code by its unique identifier
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns CodeResponse The requested QR Code
     * @throws ApiError
     */
    public static getCodesByCodeId(data: GetCodesByCodeIdData): CancelablePromise<GetCodesByCodeIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}',
            path: {
                codeId: data.codeId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Update QR Code
     * Updates an existing QR Code with new data and options. Supports changing dataType for dynamic codes (e.g., from URL to WiFi configuration). When changing dataType, ensure metadata structure matches the new dataType requirements. This operation creates a new version of the QR code.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.requestBody
     * @returns CodeResponse QR Code updated successfully
     * @throws ApiError
     */
    public static putCodesByCodeId(data: PutCodesByCodeIdData): CancelablePromise<PutCodesByCodeIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/codes/{codeId}',
            path: {
                codeId: data.codeId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to update QR Code.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Could not update code due to missing resources.',
                409: 'QR Code with same name already exists'
            }
        });
    }
    
    /**
     * Soft Delete QR Code
     * Marks a QR Code as deleted without permanently removing it from the system. Usage limits are not affected and the code can potentially be restored.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns CodeSoftDeleteResponse QR Code soft deleted successfully.
     * @throws ApiError
     */
    public static deleteCodesByCodeId(data: DeleteCodesByCodeIdData): CancelablePromise<DeleteCodesByCodeIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}',
            path: {
                codeId: data.codeId
            },
            errors: {
                400: 'QR Code is already deleted.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * List QR Codes
     * Retrieves a paginated list of QR Codes with optional filtering
     * @param data The data for the request.
     * @param data.page Page number for pagination
     * @param data.limit Number of items per page
     * @param data.orderBy Field to order results by
     * @param data.orderDirection Direction of ordering
     * @param data.name
     * @param data.workspaceId
     * @param data.isValid
     * @param data.data
     * @param data.createdAt
     * @param data.updatedAt
     * @returns unknown A paginated list of QR Codes
     * @throws ApiError
     */
    public static getCodes(data: GetCodesData = {}): CancelablePromise<GetCodesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes',
            query: {
                page: data.page,
                limit: data.limit,
                orderBy: data.orderBy,
                orderDirection: data.orderDirection,
                name: data.name,
                workspaceId: data.workspaceId,
                isValid: data.isValid,
                data: data.data,
                createdAt: data.createdAt,
                updatedAt: data.updatedAt
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, or the list of codes is empty (returned as an empty paginated response).'
            }
        });
    }
    
    /**
     * Create QR Code
     * Creates a new QR Code with the specified data and options. Supports different dataTypes for dynamic codes including WiFi configuration, contact cards (vCard), plain text, email composition, calendar events, file downloads, and custom JSON data. Each dataType has specific metadata requirements that determine how the QR code is processed when scanned.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns CodeResponse QR Code created successfully
     * @throws ApiError
     */
    public static postCodes(data: PostCodesData = {}): CancelablePromise<PostCodesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to create QR Code.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Could not create code due to missing resources.',
                409: 'QR Code with same name already exists',
                429: 'You have reached the limit for limit-codes. Please upgrade your plan to continue'
            }
        });
    }
    
    /**
     * Bulk Soft Delete QR Codes
     * Soft deletes multiple QR codes by their IDs. The codes are marked as deleted but not permanently removed from the system.
     * @returns BulkSoftDeleteCodesResponse Bulk soft delete completed with detailed results
     * @throws ApiError
     */
    public static deleteCodes(): CancelablePromise<DeleteCodesResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes',
            errors: {
                400: 'Invalid request for bulk soft delete.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found.'
            }
        });
    }
    
    /**
     * Partially update QR Code Options
     * Partially updates an existing QR Code's options using a deep merge. This will create a new version of the QR Code. Supports updating dataType for dynamic codes, which changes how the QR code content is processed when scanned (e.g., returning WiFi configuration instead of URL redirect).
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.requestBody
     * @returns CodeResponse QR Code options updated successfully, new version created.
     * @throws ApiError
     */
    public static putCodesByCodeIdOptions(data: PutCodesByCodeIdOptionsData): CancelablePromise<PutCodesByCodeIdOptionsResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/codes/{codeId}/options',
            path: {
                codeId: data.codeId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to update QR Code Options.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Bulk Permanent Delete QR Codes
     * Permanently deletes multiple QR codes by their IDs. This operation is irreversible and will remove all associated data including versions, files, and scans.
     * @returns BulkPermanentDeleteCodesResponse Bulk permanent delete completed with detailed results
     * @throws ApiError
     */
    public static deleteCodesPermanent(): CancelablePromise<DeleteCodesPermanentResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/permanent',
            errors: {
                400: 'Invalid request for bulk permanent delete.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found.'
            }
        });
    }
    
    /**
     * Delete QR Code
     * Deletes a QR Code by its unique identifier
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns FileDeleteResponse QR Code deleted successfully.
     * @throws ApiError
     */
    public static deleteCodesByCodeIdPermanent(data: DeleteCodesByCodeIdPermanentData): CancelablePromise<DeleteCodesByCodeIdPermanentResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/permanent',
            path: {
                codeId: data.codeId
            },
            errors: {
                400: 'QR Code is not soft deleted.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Restore QR Code
     * Restores a soft-deleted QR Code by setting its deleted status to false. The code becomes active again and accessible through regular endpoints.
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns CodeResponse QR Code restored successfully.
     * @throws ApiError
     */
    public static postCodesByCodeIdRestore(data: PostCodesByCodeIdRestoreData): CancelablePromise<PostCodesByCodeIdRestoreResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes/{codeId}/restore',
            path: {
                codeId: data.codeId
            },
            errors: {
                400: 'QR Code is not deleted.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Validate QR Code Options
     * Validates QR Code styling options without generating or saving the QR Code
     * @param data The data for the request.
     * @param data.requestBody
     * @returns CodeValidationResponse Validation result
     * @throws ApiError
     */
    public static postCodesValidate(data: PostCodesValidateData = {}): CancelablePromise<PostCodesValidateResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes/validate',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request to validate QR Code options.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'QR Codeor Organization not found.'
            }
        });
    }
    
    /**
     * Validate Existing QR Code
     * Validates an existing QR Code and updates its validation status in the database
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns ExistingCodeValidationResponse Validation result with detailed information
     * @throws ApiError
     */
    public static postCodesByCodeIdValidate(data: PostCodesByCodeIdValidateData): CancelablePromise<PostCodesByCodeIdValidateResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes/{codeId}/validate',
            path: {
                codeId: data.codeId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Bulk Refresh QR Code Links
     * Refreshes QR code links/files for all code versions matching the specified design element filters
     * @returns RefreshCodeLinksResponse Bulk link refresh completed
     * @throws ApiError
     */
    public static postCodesLinksRefresh(): CancelablePromise<PostCodesLinksRefreshResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes/links/refresh',
            errors: {
                400: 'Invalid request to refresh links.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found.'
            }
        });
    }
    
}

export class QrCodeLinksService {
    /**
     * List QR Code Links
     * Retrieves a paginated list of all QR Code links with optional filtering
     * @param data The data for the request.
     * @param data.page Page number for pagination
     * @param data.limit Number of items per page
     * @param data.orderBy Field to order results by
     * @param data.orderDirection Direction of ordering
     * @param data.codeId
     * @param data.type Filter by file type
     * @param data.codeName
     * @param data.codeVersion
     * @param data.codeData
     * @param data.codeType
     * @param data.codeIsValid
     * @param data.styleName
     * @param data.templateName
     * @param data.borderName
     * @param data.isCurrentVersion
     * @param data.createdByUserId
     * @param data.createdByApiKeyId
     * @param data.createdAt
     * @param data.updatedAt
     * @param data.workspaceId
     * @returns unknown A paginated list of QR Code links
     * @throws ApiError
     */
    public static getCodesLinks(data: GetCodesLinksData = {}): CancelablePromise<GetCodesLinksResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/links',
            query: {
                page: data.page,
                limit: data.limit,
                orderBy: data.orderBy,
                orderDirection: data.orderDirection,
                codeId: data.codeId,
                type: data.type,
                codeName: data.codeName,
                codeVersion: data.codeVersion,
                codeData: data.codeData,
                codeType: data.codeType,
                codeIsValid: data.codeIsValid,
                styleName: data.styleName,
                templateName: data.templateName,
                borderName: data.borderName,
                isCurrentVersion: data.isCurrentVersion,
                createdByUserId: data.createdByUserId,
                createdByApiKeyId: data.createdByApiKeyId,
                createdAt: data.createdAt,
                updatedAt: data.updatedAt,
                workspaceId: data.workspaceId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'QR Code links not found'
            }
        });
    }
    
    /**
     * Generate QR Code File Content
     * Generates a file content for a QR Code
     * @param data The data for the request.
     * @param data.type File type to generate
     * @param data.requestBody
     * @returns binary Generated QR Code file content
     * @throws ApiError
     */
    public static postCodesGenerateByType(data: PostCodesGenerateByTypeData): CancelablePromise<PostCodesGenerateByTypeResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes/generate/{type}',
            path: {
                type: data.type
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid input data',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Get QR Code Version File Content
     * Retrieves the file content of a specific QR Code version
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.version
     * @param data.type File type to generate
     * @returns binary File content for the QR Code version
     * @throws ApiError
     */
    public static getCodesByCodeIdVersionByVersionByType(data: GetCodesByCodeIdVersionByVersionByTypeData): CancelablePromise<GetCodesByCodeIdVersionByVersionByTypeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/version/{version}/{type}',
            path: {
                codeId: data.codeId,
                version: data.version,
                type: data.type
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Code, version or Organization not found.'
            }
        });
    }
    
    /**
     * Get QR Code Version Link
     * Retrieves a link to the file representation of a specific QR Code version
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.version
     * @param data.type File type to generate
     * @returns FileUrlResponse Link to the file for the QR Code version
     * @throws ApiError
     */
    public static getCodesByCodeIdVersionByVersionByTypeLink(data: GetCodesByCodeIdVersionByVersionByTypeLinkData): CancelablePromise<GetCodesByCodeIdVersionByVersionByTypeLinkResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/version/{version}/{type}/link',
            path: {
                codeId: data.codeId,
                version: data.version,
                type: data.type
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, code, version, or link not found.'
            }
        });
    }
    
    /**
     * Delete QR Code version links
     * Deletes all QR Code version links for a specific version of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.version
     * @returns unknown QR Code version links deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdVersionsByVersionLinks(data: DeleteCodesByCodeIdVersionsByVersionLinksData): CancelablePromise<DeleteCodesByCodeIdVersionsByVersionLinksResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/versions/{version}/links',
            path: {
                codeId: data.codeId,
                version: data.version
            },
            errors: {
                400: 'Invalid request to delete code version links.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, code, or version not found.'
            }
        });
    }
    
    /**
     * Delete QR Code version link by Type
     * Deletes a specific QR Code version link for a specific version of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.version
     * @param data.type File type to generate
     * @returns unknown QR Code version link deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdVersionsByVersionLinksByType(data: DeleteCodesByCodeIdVersionsByVersionLinksByTypeData): CancelablePromise<DeleteCodesByCodeIdVersionsByVersionLinksByTypeResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/versions/{version}/links/{type}',
            path: {
                codeId: data.codeId,
                version: data.version,
                type: data.type
            },
            errors: {
                400: 'Invalid request to delete code version link by type.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, code, version, or link not found.'
            }
        });
    }
    
    /**
     * Delete All QR Code Versions Links
     * Deletes all file links for all versions of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns unknown QR Code version links deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdVersionsLinks(data: DeleteCodesByCodeIdVersionsLinksData): CancelablePromise<DeleteCodesByCodeIdVersionsLinksResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/versions/links',
            path: {
                codeId: data.codeId
            },
            errors: {
                400: 'Invalid request to delete all code versions links.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Delete All QR Code Versions Links by Type
     * Deletes a specific file type link for all versions of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.type File type to generate
     * @returns unknown QR Code version links deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdVersionsLinksByType(data: DeleteCodesByCodeIdVersionsLinksByTypeData): CancelablePromise<DeleteCodesByCodeIdVersionsLinksByTypeResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/versions/links/{type}',
            path: {
                codeId: data.codeId,
                type: data.type
            },
            errors: {
                400: 'Invalid request to delete all code versions links by type.',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Get QR Code File Content (SVG, PNG, PDF)
     * Retrieves the SVG, PNG, or PDF representation of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.type File type to generate
     * @returns binary SVG, PNG, or PDF content for the QR Code
     * @throws ApiError
     */
    public static getCodesByCodeIdByType(data: GetCodesByCodeIdByTypeData): CancelablePromise<GetCodesByCodeIdByTypeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/{type}',
            path: {
                codeId: data.codeId,
                type: data.type
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Get QR Code link
     * Retrieves a link to the SVG, PNG, or PDF representation of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.type File type to generate
     * @returns FileUrlResponse Link to the SVG, PNG, or PDF file for the QR Code
     * @throws ApiError
     */
    public static getCodesByCodeIdByTypeLink(data: GetCodesByCodeIdByTypeLinkData): CancelablePromise<GetCodesByCodeIdByTypeLinkResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/{type}/link',
            path: {
                codeId: data.codeId,
                type: data.type
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Delete QR Code links
     * Deletes all links for the current version of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns unknown QR Code links deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdLinks(data: DeleteCodesByCodeIdLinksData): CancelablePromise<DeleteCodesByCodeIdLinksResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/links',
            path: {
                codeId: data.codeId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Delete QR Code link by Type
     * Deletes a specific file type link for the current version of a QR Code
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.type File type to generate
     * @returns unknown QR Code link deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdLinksByType(data: DeleteCodesByCodeIdLinksByTypeData): CancelablePromise<DeleteCodesByCodeIdLinksByTypeResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/links/{type}',
            path: {
                codeId: data.codeId,
                type: data.type
            },
            errors: {
                400: 'Invalid input data',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, code, or link not found.'
            }
        });
    }
    
}

export class QrCodeVersionsService {
    /**
     * Get QR Code version
     * Retrieves a specific version of a QR Code by ID and version number
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.version
     * @returns CodeVersionResponse The requested QR Code version version
     * @throws ApiError
     */
    public static getCodesByCodeIdVersionByVersion(data: GetCodesByCodeIdVersionByVersionData): CancelablePromise<GetCodesByCodeIdVersionByVersionResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/version/{version}',
            path: {
                codeId: data.codeId,
                version: data.version
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Code, version or Organization not found.'
            }
        });
    }
    
    /**
     * List QR Code versions
     * Retrieves all versions of a QR Code by its unique identifier
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns unknown A paginated list of QR Code versions
     * @throws ApiError
     */
    public static getCodesByCodeIdVersions(data: GetCodesByCodeIdVersionsData): CancelablePromise<GetCodesByCodeIdVersionsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/codes/{codeId}/versions',
            path: {
                codeId: data.codeId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found, or code has no versions.'
            }
        });
    }
    
    /**
     * Delete All QR Code Versions
     * Deletes all versions of a QR Code except the current one
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @returns CodeVersionsDeleteResponse All versions deleted successfully
     * @throws ApiError
     */
    public static deleteCodesByCodeIdVersions(data: DeleteCodesByCodeIdVersionsData): CancelablePromise<DeleteCodesByCodeIdVersionsResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/codes/{codeId}/versions',
            path: {
                codeId: data.codeId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or code not found.'
            }
        });
    }
    
    /**
     * Restore QR Code Version
     * Restores a specific version of a QR Code as the current version
     * @param data The data for the request.
     * @param data.codeId Unique identifier of the QR Code
     * @param data.version
     * @returns CodeVersionResponse QR Code version restored successfully
     * @throws ApiError
     */
    public static postCodesByCodeIdVersionByVersionRestore(data: PostCodesByCodeIdVersionByVersionRestoreData): CancelablePromise<PostCodesByCodeIdVersionByVersionRestoreResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/codes/{codeId}/version/{version}/restore',
            path: {
                codeId: data.codeId,
                version: data.version
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization, code, or version not found.'
            }
        });
    }
    
}

export class TemplatesService {
    /**
     * Create a new template
     * Creates a new QR code template for an organization or workspace.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns TemplateResponse Template created successfully
     * @throws ApiError
     */
    public static postTemplates(data: PostTemplatesData = {}): CancelablePromise<PostTemplatesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/templates',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when creating template',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Could not create template due to missing resources.'
            }
        });
    }
    
    /**
     * List all templates
     * Retrieves all templates available to the user, grouped by organization and workspace.
     * @param data The data for the request.
     * @param data.name Filter by template name
     * @returns GetTemplatesResponse List of templates
     * @throws ApiError
     */
    public static getTemplates(data: GetTemplatesData = {}): CancelablePromise<GetTemplatesResponse2> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/templates',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found, no templates available, or the list of templates is empty.'
            }
        });
    }
    
    /**
     * List base templates
     * Retrieves all base templates from the QRCodeJs library with optional name filtering.
     * @param data The data for the request.
     * @param data.name Filter templates by name (partial match)
     * @returns BaseTemplates List of base templates
     * @throws ApiError
     */
    public static getTemplatesBase(data: GetTemplatesBaseData = {}): CancelablePromise<GetTemplatesBaseResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/templates/base',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden'
            }
        });
    }
    
    /**
     * Get template by ID
     * Retrieves a template by its unique identifier.
     * @param data The data for the request.
     * @param data.templateId
     * @returns TemplateResponse Template details
     * @throws ApiError
     */
    public static getTemplatesByTemplateId(data: GetTemplatesByTemplateIdData): CancelablePromise<GetTemplatesByTemplateIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/templates/{templateId}',
            path: {
                templateId: data.templateId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or template not found.'
            }
        });
    }
    
    /**
     * Update template by ID
     * Updates a template by its unique identifier.
     * @param data The data for the request.
     * @param data.templateId
     * @param data.requestBody
     * @returns TemplateResponse Template updated successfully
     * @throws ApiError
     */
    public static putTemplatesByTemplateId(data: PutTemplatesByTemplateIdData): CancelablePromise<PutTemplatesByTemplateIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/templates/{templateId}',
            path: {
                templateId: data.templateId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating template',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or template not found.'
            }
        });
    }
    
    /**
     * Delete template by ID
     * Deletes a template by its unique identifier. Fails if the template is used by codes.
     * @param data The data for the request.
     * @param data.templateId
     * @returns unknown Template deleted successfully
     * @throws ApiError
     */
    public static deleteTemplatesByTemplateId(data: DeleteTemplatesByTemplateIdData): CancelablePromise<DeleteTemplatesByTemplateIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/templates/{templateId}',
            path: {
                templateId: data.templateId
            },
            errors: {
                400: 'Bad Request when deleting template',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or template not found.'
            }
        });
    }
    
    /**
     * Partially update template options by ID
     * Partially updates a template options by its unique identifier using a deep merge. Use null to delete a field.
     * @param data The data for the request.
     * @param data.templateId
     * @param data.requestBody
     * @returns TemplateResponse Template options updated successfully
     * @throws ApiError
     */
    public static putTemplatesByTemplateIdOptions(data: PutTemplatesByTemplateIdOptionsData): CancelablePromise<PutTemplatesByTemplateIdOptionsResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/templates/{templateId}/options',
            path: {
                templateId: data.templateId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating template options',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or template not found.'
            }
        });
    }
    
    /**
     * List templates for a workspace
     * Retrieves all templates for a specific workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.name Filter by template name
     * @returns TemplateArrayResponse List of templates for the workspace
     * @throws ApiError
     */
    public static getTemplatesWorkspaceByWorkspaceId(data: GetTemplatesWorkspaceByWorkspaceIdData): CancelablePromise<GetTemplatesWorkspaceByWorkspaceIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/templates/workspace/{workspaceId}',
            path: {
                workspaceId: data.workspaceId
            },
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or workspace not found, or no templates in workspace.'
            }
        });
    }
    
}

export class StylesService {
    /**
     * Create a new style
     * Creates a new style for an organization or workspace.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns StyleResponse Style created successfully
     * @throws ApiError
     */
    public static postStyles(data: PostStylesData = {}): CancelablePromise<PostStylesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/styles',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when creating style',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or Workspace context not found during style creation.'
            }
        });
    }
    
    /**
     * List all styles
     * Retrieves all styles available to the user.
     * @param data The data for the request.
     * @param data.name Filter by style name
     * @returns GetStylesResponse List of styles
     * @throws ApiError
     */
    public static getStyles(data: GetStylesData = {}): CancelablePromise<GetStylesResponse2> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/styles',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'No styles found for the organization context, or organization context invalid.'
            }
        });
    }
    
    /**
     * List base styles
     * Retrieves all base styles from the QRCodeJs library with optional name filtering.
     * @param data The data for the request.
     * @param data.name Filter styles by name (partial match)
     * @returns BaseStyles List of base styles
     * @throws ApiError
     */
    public static getStylesBase(data: GetStylesBaseData = {}): CancelablePromise<GetStylesBaseResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/styles/base',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden'
            }
        });
    }
    
    /**
     * Get style by ID
     * Retrieves a style by its unique identifier.
     * @param data The data for the request.
     * @param data.styleId
     * @returns StyleResponse Style details
     * @throws ApiError
     */
    public static getStylesByStyleId(data: GetStylesByStyleIdData): CancelablePromise<GetStylesByStyleIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/styles/{styleId}',
            path: {
                styleId: data.styleId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Style not found, or its parent organization context is invalid.'
            }
        });
    }
    
    /**
     * Update style by ID
     * Updates a style by its unique identifier.
     * @param data The data for the request.
     * @param data.styleId
     * @param data.requestBody
     * @returns StyleResponse Style updated successfully
     * @throws ApiError
     */
    public static putStylesByStyleId(data: PutStylesByStyleIdData): CancelablePromise<PutStylesByStyleIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/styles/{styleId}',
            path: {
                styleId: data.styleId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating style',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Style to update not found, or its parent organization context is invalid.'
            }
        });
    }
    
    /**
     * Delete style by ID
     * Deletes a style by its unique identifier. Fails if the style is used by codes.
     * @param data The data for the request.
     * @param data.styleId
     * @returns unknown Style deleted successfully
     * @throws ApiError
     */
    public static deleteStylesByStyleId(data: DeleteStylesByStyleIdData): CancelablePromise<DeleteStylesByStyleIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/styles/{styleId}',
            path: {
                styleId: data.styleId
            },
            errors: {
                400: 'Bad Request when deleting style',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Style to delete not found, or its parent organization context is invalid.'
            }
        });
    }
    
    /**
     * Partially update style options by ID
     * Partially updates a style options by its unique identifier using a deep merge. Use null to delete a field.
     * @param data The data for the request.
     * @param data.styleId
     * @param data.requestBody
     * @returns StyleResponse Style options updated successfully
     * @throws ApiError
     */
    public static putStylesByStyleIdOptions(data: PutStylesByStyleIdOptionsData): CancelablePromise<PutStylesByStyleIdOptionsResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/styles/{styleId}/options',
            path: {
                styleId: data.styleId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating style options',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or style not found.'
            }
        });
    }
    
    /**
     * List styles for a workspace
     * Retrieves all styles for a specific workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.name Filter by style name
     * @returns StyleArray List of styles for the workspace
     * @throws ApiError
     */
    public static getStylesWorkspaceByWorkspaceId(data: GetStylesWorkspaceByWorkspaceIdData): CancelablePromise<GetStylesWorkspaceByWorkspaceIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/styles/workspace/{workspaceId}',
            path: {
                workspaceId: data.workspaceId
            },
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'No styles found for the workspace (returns empty array), or workspace itself not found.'
            }
        });
    }
    
}

export class TextsService {
    /**
     * Create a new text
     * Creates a new text for an organization or workspace.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns TextResponse Text created successfully
     * @throws ApiError
     */
    public static postTexts(data: PostTextsData = {}): CancelablePromise<PostTextsResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/texts',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when creating text',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Could not create text entity due to missing resources.'
            }
        });
    }
    
    /**
     * List all texts
     * Retrieves all texts available to the user.
     * @param data The data for the request.
     * @param data.name Filter by text name
     * @returns GetTextsResponse List of texts
     * @throws ApiError
     */
    public static getTexts(data: GetTextsData = {}): CancelablePromise<GetTextsResponse2> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/texts',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found or no text entities available.'
            }
        });
    }
    
    /**
     * List base texts
     * Retrieves all base text templates from the QRCodeJs library with optional name filtering.
     * @param data The data for the request.
     * @param data.name Filter texts by name (partial match)
     * @returns BaseTexts List of base texts
     * @throws ApiError
     */
    public static getTextsBase(data: GetTextsBaseData = {}): CancelablePromise<GetTextsBaseResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/texts/base',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden'
            }
        });
    }
    
    /**
     * Get text by ID
     * Retrieves a text by its unique identifier.
     * @param data The data for the request.
     * @param data.textId
     * @returns TextResponse Text details
     * @throws ApiError
     */
    public static getTextsByTextId(data: GetTextsByTextIdData): CancelablePromise<GetTextsByTextIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/texts/{textId}',
            path: {
                textId: data.textId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or text entity not found.'
            }
        });
    }
    
    /**
     * Update text by ID
     * Updates a text by its unique identifier.
     * @param data The data for the request.
     * @param data.textId
     * @param data.requestBody
     * @returns TextResponse Text updated successfully
     * @throws ApiError
     */
    public static putTextsByTextId(data: PutTextsByTextIdData): CancelablePromise<PutTextsByTextIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/texts/{textId}',
            path: {
                textId: data.textId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating text',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or text entity not found.'
            }
        });
    }
    
    /**
     * Delete text by ID
     * Deletes a text by its unique identifier. Fails if the text is used by codes.
     * @param data The data for the request.
     * @param data.textId
     * @returns DeleteTextResponse Text deleted successfully
     * @throws ApiError
     */
    public static deleteTextsByTextId(data: DeleteTextsByTextIdData): CancelablePromise<DeleteTextsByTextIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/texts/{textId}',
            path: {
                textId: data.textId
            },
            errors: {
                400: 'Bad Request when deleting text',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or text entity not found.'
            }
        });
    }
    
    /**
     * Partially update text options by ID
     * Partially updates a text options by its unique identifier using a deep merge. Use null to delete a field.
     * @param data The data for the request.
     * @param data.textId
     * @param data.requestBody
     * @returns TextResponse Text options updated successfully
     * @throws ApiError
     */
    public static putTextsByTextIdOptions(data: PutTextsByTextIdOptionsData): CancelablePromise<PutTextsByTextIdOptionsResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/texts/{textId}/options',
            path: {
                textId: data.textId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating text options',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or text not found.'
            }
        });
    }
    
    /**
     * List texts for a workspace
     * Retrieves all texts for a specific workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.name Filter by text name
     * @returns TextArray List of texts for the workspace
     * @throws ApiError
     */
    public static getTextsWorkspaceByWorkspaceId(data: GetTextsWorkspaceByWorkspaceIdData): CancelablePromise<GetTextsWorkspaceByWorkspaceIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/texts/workspace/{workspaceId}',
            path: {
                workspaceId: data.workspaceId
            },
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or workspace not found, or no text entities in workspace.'
            }
        });
    }
    
}

export class BordersService {
    /**
     * Create a new border
     * Creates a new border for an organization or workspace.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns BorderResponse Border created successfully
     * @throws ApiError
     */
    public static postBorders(data: PostBordersData = {}): CancelablePromise<PostBordersResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/borders',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when creating a border',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Could not create border entity due to missing resources.'
            }
        });
    }
    
    /**
     * List all borders
     * Retrieves all borders available to the user.
     * @param data The data for the request.
     * @param data.name Filter by border name
     * @returns GetBordersResponse List of borders
     * @throws ApiError
     */
    public static getBorders(data: GetBordersData = {}): CancelablePromise<GetBordersResponse2> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/borders',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization not found or no border entities available.'
            }
        });
    }
    
    /**
     * List base borders
     * Retrieves all base border templates from the QRCodeJs library with optional name filtering.
     * @param data The data for the request.
     * @param data.name Filter borders by name (partial match)
     * @returns BaseBorders List of base borders
     * @throws ApiError
     */
    public static getBordersBase(data: GetBordersBaseData = {}): CancelablePromise<GetBordersBaseResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/borders/base',
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden'
            }
        });
    }
    
    /**
     * Get border by ID
     * Retrieves a border by its unique identifier.
     * @param data The data for the request.
     * @param data.borderId
     * @returns BorderResponse Border details
     * @throws ApiError
     */
    public static getBordersByBorderId(data: GetBordersByBorderIdData): CancelablePromise<GetBordersByBorderIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/borders/{borderId}',
            path: {
                borderId: data.borderId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or border entity not found.'
            }
        });
    }
    
    /**
     * Update border by ID
     * Updates a border by its unique identifier.
     * @param data The data for the request.
     * @param data.borderId
     * @param data.requestBody
     * @returns BorderResponse Border updated successfully
     * @throws ApiError
     */
    public static putBordersByBorderId(data: PutBordersByBorderIdData): CancelablePromise<PutBordersByBorderIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/borders/{borderId}',
            path: {
                borderId: data.borderId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating a border',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or border entity not found.'
            }
        });
    }
    
    /**
     * Delete border by ID
     * Deletes a border by its unique identifier.
     * @param data The data for the request.
     * @param data.borderId
     * @returns DeleteBorderResponse Border deleted successfully
     * @throws ApiError
     */
    public static deleteBordersByBorderId(data: DeleteBordersByBorderIdData): CancelablePromise<DeleteBordersByBorderIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/borders/{borderId}',
            path: {
                borderId: data.borderId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or border entity not found.'
            }
        });
    }
    
    /**
     * Partially update border options by ID
     * Partially updates border options by its unique identifier using a deep merge. Use null to delete a field.
     * @param data The data for the request.
     * @param data.borderId
     * @param data.requestBody
     * @returns BorderResponse Border options updated successfully
     * @throws ApiError
     */
    public static putBordersByBorderIdOptions(data: PutBordersByBorderIdOptionsData): CancelablePromise<PutBordersByBorderIdOptionsResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/borders/{borderId}/options',
            path: {
                borderId: data.borderId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request when updating border options',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or border not found.'
            }
        });
    }
    
    /**
     * List borders for a workspace
     * Retrieves all borders for a specific workspace.
     * @param data The data for the request.
     * @param data.workspaceId
     * @param data.name Filter by border name
     * @returns BorderResponse List of borders for the workspace
     * @throws ApiError
     */
    public static getBordersWorkspaceByWorkspaceId(data: GetBordersWorkspaceByWorkspaceIdData): CancelablePromise<GetBordersWorkspaceByWorkspaceIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/borders/workspace/{workspaceId}',
            path: {
                workspaceId: data.workspaceId
            },
            query: {
                name: data.name
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Organization or workspace not found, or no border entities in workspace.'
            }
        });
    }
    
}

export class CountryCodesService {
    /**
     * List All Country Codes
     * Retrieves a list of all available country codes with their names and full names
     * @returns unknown A list of all country codes
     * @throws ApiError
     */
    public static getCountryCodes(): CancelablePromise<GetCountryCodesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/country-codes'
        });
    }
    
}

export class RouterRuleTemplatesService {
    /**
     * Create Router Rule Template
     * Creates a new router rule template. The template can be organization-level (no workspaceId) or workspace-specific. Template names must be unique within the organization scope.
     * @param data The data for the request.
     * @param data.requestBody Router rule template creation data
     * @returns unknown Router rule template created successfully
     * @throws ApiError
     */
    public static postRouterRuleTemplates(data: PostRouterRuleTemplatesData = {}): CancelablePromise<PostRouterRuleTemplatesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/router-rule-templates',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request data or template name already exists',
                401: 'Unauthorized',
                403: 'Forbidden',
                429: 'You have reached the limit for router rule templates. Please upgrade your plan to continue'
            }
        });
    }
    
    /**
     * List Router Rule Templates
     * Retrieves available router rule templates based on user access. Returns global templates (if includeGlobal=true), organization-level templates, and workspace-specific templates the user has access to.
     * @param data The data for the request.
     * @param data.page Page number for pagination
     * @param data.limit Number of items to return (1-100)
     * @param data.includeGlobal Include global platform templates in results
     * @param data.type Filter templates by router rule type
     * @returns unknown A paginated list of router rule templates with metadata
     * @throws ApiError
     */
    public static getRouterRuleTemplates(data: GetRouterRuleTemplatesData = {}): CancelablePromise<GetRouterRuleTemplatesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/router-rule-templates',
            query: {
                page: data.page,
                limit: data.limit,
                includeGlobal: data.includeGlobal,
                type: data.type
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden'
            }
        });
    }
    
    /**
     * Get Router Rule Template
     * Retrieves a specific router rule template by ID. Returns global templates and organization templates the user has access to.
     * @param data The data for the request.
     * @param data.templateId Unique identifier of the router rule template
     * @param data.routerRuleTemplateId
     * @returns unknown Router rule template details
     * @throws ApiError
     */
    public static getRouterRuleTemplatesByRouterRuleTemplateId(data: GetRouterRuleTemplatesByRouterRuleTemplateIdData): CancelablePromise<GetRouterRuleTemplatesByRouterRuleTemplateIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/router-rule-templates/{routerRuleTemplateId}',
            path: {
                templateId: data.templateId,
                routerRuleTemplateId: data.routerRuleTemplateId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Router rule template not found, or organization/workspace context not found.'
            }
        });
    }
    
    /**
     * Update Router Rule Template
     * Updates a router rule template. Only organization templates can be updated (not global templates). Users can only update templates within their organization.
     * @param data The data for the request.
     * @param data.templateId Unique identifier of the router rule template
     * @param data.routerRuleTemplateId
     * @param data.requestBody Router rule template update data
     * @returns unknown Router rule template updated successfully
     * @throws ApiError
     */
    public static putRouterRuleTemplatesByRouterRuleTemplateId(data: PutRouterRuleTemplatesByRouterRuleTemplateIdData): CancelablePromise<PutRouterRuleTemplatesByRouterRuleTemplateIdResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/router-rule-templates/{routerRuleTemplateId}',
            path: {
                templateId: data.templateId,
                routerRuleTemplateId: data.routerRuleTemplateId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request data for template update',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Router rule template not found, or organization/workspace context not found.'
            }
        });
    }
    
    /**
     * Delete Router Rule Template
     * Deletes a router rule template. Templates that are currently being used by router rules cannot be deleted. Only organization templates can be deleted (not global templates).
     * @param data The data for the request.
     * @param data.templateId Unique identifier of the router rule template
     * @param data.routerRuleTemplateId
     * @returns unknown Router rule template deleted successfully
     * @throws ApiError
     */
    public static deleteRouterRuleTemplatesByRouterRuleTemplateId(data: DeleteRouterRuleTemplatesByRouterRuleTemplateIdData): CancelablePromise<DeleteRouterRuleTemplatesByRouterRuleTemplateIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/router-rule-templates/{routerRuleTemplateId}',
            path: {
                templateId: data.templateId,
                routerRuleTemplateId: data.routerRuleTemplateId
            },
            errors: {
                400: 'Template is in use and cannot be deleted',
                401: 'Unauthorized',
                403: 'Forbidden',
                404: 'Router rule template not found, or organization/workspace context not found.'
            }
        });
    }
    
    /**
     * Create Workspace Router Rule Template
     * Creates a new router rule template scoped to the specified workspace. Template names must be unique within the organization scope. The workspaceId from the URL path will be used to scope the template.
     * @param data The data for the request.
     * @param data.workspaceId Unique identifier of the workspace to scope the template to
     * @param data.requestBody Workspace router rule template creation data (workspaceId will be taken from URL)
     * @returns unknown Workspace router rule template created successfully
     * @throws ApiError
     */
    public static postWorkspacesByWorkspaceIdRouterRuleTemplates(data: PostWorkspacesByWorkspaceIdRouterRuleTemplatesData): CancelablePromise<PostWorkspacesByWorkspaceIdRouterRuleTemplatesResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/workspaces/{workspaceId}/router-rule-templates',
            path: {
                workspaceId: data.workspaceId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request data, template name already exists, or insufficient workspace permissions',
                401: 'Unauthorized',
                403: 'Forbidden',
                429: 'You have reached the limit for router rule templates. Please upgrade your plan to continue'
            }
        });
    }
    
}